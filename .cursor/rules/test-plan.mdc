---
description: 
globs: 
alwaysApply: false
---
Jesteś doświadczonym inżynierem QA, którego zadaniem jest stworzenie kompleksowego planu testów dla projektu programistycznego. Przeanalizuj poniższe informacje o projekcie:

<kod_projektu>
Directory structure:
└── nickers-quickshop/
    ├── README.md
    ├── code/
    │   ├── README.md
    │   ├── biome.json
    │   ├── components.json
    │   ├── index.html
    │   ├── package.json
    │   ├── tsconfig.json
    │   ├── vite.config.ts
    │   ├── .cta.json
    │   ├── .env.local.template
    │   ├── public/
    │   │   ├── manifest.json
    │   │   └── robots.txt
    │   ├── src/
    │   │   ├── config.ts
    │   │   ├── main.tsx
    │   │   ├── reportWebVitals.ts
    │   │   ├── routeTree.gen.ts
    │   │   ├── styles.css
    │   │   ├── components/
    │   │   │   ├── Header.tsx
    │   │   │   ├── auth/
    │   │   │   │   ├── AuthModeSwitch.tsx
    │   │   │   │   ├── EmailAuthForm.tsx
    │   │   │   │   └── GoogleAuthButton.tsx
    │   │   │   ├── layout/
    │   │   │   │   ├── BottomNav.tsx
    │   │   │   │   └── MainLayout.tsx
    │   │   │   ├── list-details/
    │   │   │   │   ├── ActiveItemsList.tsx
    │   │   │   │   ├── CompletedItemsSection.tsx
    │   │   │   │   ├── ItemConflictDialog.tsx
    │   │   │   │   ├── ListDetailsHeader.tsx
    │   │   │   │   ├── ListItemRow.tsx
    │   │   │   │   ├── SetConflictResolutionDialog.tsx
    │   │   │   │   └── StickyInputBar.tsx
    │   │   │   ├── lists/
    │   │   │   │   ├── CreateListDialog.tsx
    │   │   │   │   ├── ListCard.tsx
    │   │   │   │   ├── ListsGrid.tsx
    │   │   │   │   └── ListsHeader.tsx
    │   │   │   ├── set-details/
    │   │   │   │   ├── SetDetailsHeader.tsx
    │   │   │   │   ├── SetItemRow.tsx
    │   │   │   │   └── SetItemsList.tsx
    │   │   │   ├── sets/
    │   │   │   │   ├── AddSetToListDialog.tsx
    │   │   │   │   ├── CreateSetDialog.tsx
    │   │   │   │   ├── SetCard.tsx
    │   │   │   │   ├── SetsGrid.tsx
    │   │   │   │   └── SetsHeader.tsx
    │   │   │   └── ui/
    │   │   │       ├── button.tsx
    │   │   │       ├── card.tsx
    │   │   │       ├── checkbox.tsx
    │   │   │       ├── dialog.tsx
    │   │   │       ├── dropdown-menu.tsx
    │   │   │       ├── input.tsx
    │   │   │       ├── label.tsx
    │   │   │       ├── separator.tsx
    │   │   │       └── tabs.tsx
    │   │   ├── db/
    │   │   │   ├── database.types.ts
    │   │   │   └── supabase.client.ts
    │   │   ├── hooks/
    │   │   │   ├── useListDetails.ts
    │   │   │   ├── useListsView.ts
    │   │   │   ├── useSetDetails.ts
    │   │   │   └── useSetsView.ts
    │   │   ├── integrations/
    │   │   │   └── tanstack-query/
    │   │   │       ├── devtools.tsx
    │   │   │       └── root-provider.tsx
    │   │   ├── lib/
    │   │   │   └── utils.ts
    │   │   ├── routes/
    │   │   │   ├── __root.tsx
    │   │   │   ├── auth.tsx
    │   │   │   ├── history.tsx
    │   │   │   ├── index.tsx
    │   │   │   ├── lists.$listId.tsx
    │   │   │   ├── lists.index.tsx
    │   │   │   ├── lists.tsx
    │   │   │   ├── sets.$setId.tsx
    │   │   │   ├── sets.index.tsx
    │   │   │   ├── sets.tsx
    │   │   │   └── demo/
    │   │   │       └── tanstack-query.tsx
    │   │   ├── services/
    │   │   │   ├── history.service.ts
    │   │   │   ├── items.service.ts
    │   │   │   ├── lists.service.ts
    │   │   │   └── sets.service.ts
    │   │   └── types/
    │   │       ├── auth.types.ts
    │   │       └── domain.types.ts
    │   └── supabase/
    │       ├── APPLY_FIX.sql
    │       ├── APPLY_FIX_COMPLETE.sql
    │       ├── FIX_EXISTING_LISTS.sql
    │       └── migrations/
    │           ├── 20260128120000_initial_schema.sql
    │           ├── 20260130230000_fix_list_members_rls.sql
    │           ├── 20260130231500_fix_lists_rls.sql
    │           ├── 20260130232000_fix_list_members_insert_recursion.sql
    │           ├── 20260130233000_add_invite_member_function.sql
    │           ├── 20260131000000_fix_set_members_rls_and_invite.sql
    │           └── 20260131000001_fix_sets_rls.sql
    ├── .ai/
    │   ├── auth-implementation-summary.md
    │   ├── auth-view-view-implementation-plan.md
    │   ├── business-logic-plan.md
    │   ├── database-fix-guide.md
    │   ├── db-plan.md
    │   ├── fix-missing-list-members.md
    │   ├── full-impl-plan-04-list-details-view-implementation-plan.md
    │   ├── full-impl-plan-05-sets-dashboard-view-implementation-plan.md
    │   ├── full-impl-plan-05-verification-report.md
    │   ├── full-impl-plan-06-set-details-view-implementation-plan.md
    │   ├── impl-plan-01-layout-navigation.md
    │   ├── impl-plan-02-auth.md
    │   ├── impl-plan-03-lists-dashboard.md
    │   ├── impl-plan-04-list-details.md
    │   ├── impl-plan-05-sets-dashboard.md
    │   ├── impl-plan-06-set-details.md
    │   ├── impl-plan-07-history.md
    │   ├── impl-plan-08-modals-share.md
    │   ├── impl-plan-09-sync-ux.md
    │   ├── list-details-view-implementation-plan.md
    │   ├── lists-view-implementation-plan.md
    │   ├── lists-view-implementation-summary.md
    │   ├── prd.md
    │   ├── QUICK_FIX_INSTRUCTIONS.md
    │   ├── security-definer-explanation.md
    │   ├── tech-stack.md
    │   ├── ui-plan-parts.md
    │   ├── ui-plan.md
    │   ├── ui-session.md
    │   └── diagrams/
    │       └── journey.md
    ├── .cursor/
    │   └── rules/
    │       ├── frontend-react-guidelines.mdc
    │       ├── mermaid-diagram-auth.mdc
    │       ├── mermaid-diagram-journey.mdc
    │       ├── mermaid-diagram-ui.mdc
    │       └── ui-shadcn-helper.mdc
    ├── .gemini-cli/
    │   ├── readme.md
    │   ├── browser.sh
    │   ├── docker-compose.yml
    │   ├── Dockerfile
    │   └── start.cmd
    └── .prompts/
        ├── after-ui-check-consistency-prompt.md
        ├── analiza.md
        ├── db-create-doc.md
        ├── db-session.md
        ├── db-summary.md
        ├── generate-readme-prompt.md
        ├── implementacja-widoku-prompt.md
        ├── prd-prompt.md
        ├── propose-interface-prompt.md
        ├── stack-prompt-2.md
        ├── stack-prompt.md
        ├── supabase-initialization-prompt.md
        ├── ui-high-lever-plan-prompt.md
        ├── ui-sesja-planowania-kopie.md
        ├── wynik-db-summary.md
        ├── bugs/
        │   └── offline-first.md
        ├── prd-generation/
        │   ├── 01_wymagania_projektowe.md
        │   ├── 02_wymagania_projektowe-copilot.md
        │   ├── 02_wymagania_projektowe-gemini_01_pytania.md
        │   ├── 03_wymagania_projektowe-gemini_01_odpowiedzi.md
        │   ├── 04_wymagania_projektowe-gemini_02_pytania.md
        │   ├── 05_wymagania_projektowe-gemini_02_odpowiedzi.md
        │   ├── 06_wymagania_projektowe-gemini_03_pytania.md
        │   ├── 07_wymagania_projektowe-gemini_03_odpowiedzi.md
        │   └── 08_prd-gemini.md
        └── ui-plan/
            ├── auth-view-prompt.md
            ├── impl-plan-01-layout-navigation.md
            ├── impl-plan-02-auth.md
            ├── impl-plan-03-lists-dashboard.md
            ├── impl-plan-04-list-details.md
            ├── impl-plan-05-sets-dashboard.md
            ├── impl-plan-06-set-details.md
            ├── impl-plan-07-history.md
            ├── impl-plan-08-modals-share.md
            ├── impl-plan-09-sync-ux.md
            ├── list-details-view-prompt.md
            ├── lists-view-prompt.md
            ├── prompt-to-create-prompt-for-impl-plan.md
            └── template-prompt.md


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# QuickShop

QuickShop is a Mobile-First Progressive Web App (PWA) designed to streamline the grocery shopping process. It addresses the common issue of forgetting regularly purchased items by utilizing a template mechanism (sets) and providing real-time synchronization of shopping lists between users.

## Project Description

QuickShop aims to provide a simple, intuitive tool that minimizes the time spent creating shopping lists and increases the completeness of purchases. The application features a minimalist design with a focus on usability.

**Key Features:**
*   **Real-time Synchronization:** Changes made by one user are instantly visible to others via WebSockets.
*   **Offline Support:** Works without an internet connection using Optimistic UI and local caching, syncing when connectivity is restored.
*   **Smart Lists:** Features like duplicate detection and drag-and-drop sorting.
*   **Templates (Sets):** Create reusable sets of products (e.g., "Breakfast", "Weekend") to quickly populate lists.
*   **History:** Archive and view past shopping trips.

## Tech Stack

**Frontend:**
*   **Framework:** React 19 + Vite
*   **Styling:** Tailwind CSS 4
*   **Components:** Material Design principles
*   **Icons:** Lucide React

**State & Data:**
*   **State Management:** TanStack Query (with persistent cache)
*   **Routing:** TanStack Router
*   **Backend as a Service:** Supabase (PostgreSQL, Auth, Realtime)

**Development & Testing:**
*   **Language:** TypeScript
*   **Testing:** Vitest, React Testing Library
*   **Linting/Formatting:** Biome

## Getting Started Locally

To get a local copy of the project up and running, follow these steps.

### Prerequisites
*   Node.js (Latest LTS version recommended)
*   npm (comes with Node.js)

### Installation

1.  **Clone the repository:**
    ```bash
    git clone <repository-url>
    cd quickshop
    ```

2.  **Navigate to the code directory:**
    The source code is located in the `code` folder.
    ```bash
    cd code
    ```

3.  **Install dependencies:**
    ```bash
    npm install
    ```

4.  **Configure Environment Variables:**
    Create a `.env` file in the `code` directory based on `.env.local.template` (if available). You will need to configure your Supabase credentials:
    ```env
    VITE_SUPABASE_URL=your_supabase_url
    VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
    ```

5.  **Run the development server:**
    ```bash
    npm run dev
    ```
    The application will be accessible at `http://localhost:3000`.

## Available Scripts

All commands should be run from the `code` directory.

*   `npm run dev`: Starts the development server.
*   `npm run build`: Builds the app for production (tsc + vite build).
*   `npm run preview`: Previews the production build locally.
*   `npm run test`: Runs unit tests using Vitest.
*   `npm run format`: Formats the codebase using Biome.
*   `npm run lint`: Runs the Biome linter.
*   `npm run check`: Runs Biome check (linting + formatting verification).

## Project Scope

The current MVP (Minimum Viable Product) focuses on the core shopping experience:

*   **Authentication:** Email/Password and Google OAuth.
*   **List Management:** Create, edit, archive, and share lists.
*   **Product Actions:** Add, edit, delete, mark as bought, and sort items.
*   **Sets:** Management of reusable product templates.
*   **History:** View shopping history for the last 365 days.

**Future Scope (Out of MVP):**
*   Barcode scanning
*   Recipe integration
*   Price comparison
*   Dark mode

## Project Status

**In Development**

The project is currently in the active development phase, focusing on implementing core features defined in the MVP.

## License

This project is private and proprietary.



================================================
FILE: code/README.md
================================================
Welcome to your new TanStack app! 

# Getting Started

To run this application:

```bash
npm install
npm run start
```

# Building For Production

To build this application for production:

```bash
npm run build
```

## Testing

This project uses [Vitest](https://vitest.dev/) for testing. You can run the tests with:

```bash
npm run test
```

## Styling

This project uses [Tailwind CSS](https://tailwindcss.com/) for styling.


## Linting & Formatting

This project uses [Biome](https://biomejs.dev/) for linting and formatting. The following scripts are available:


```bash
npm run lint
npm run format
npm run check
```



## Routing
This project uses [TanStack Router](https://tanstack.com/router). The initial setup is a file based router. Which means that the routes are managed as files in `src/routes`.

### Adding A Route

To add a new route to your application just add another a new file in the `./src/routes` directory.

TanStack will automatically generate the content of the route file for you.

Now that you have two routes you can use a `Link` component to navigate between them.

### Adding Links

To use SPA (Single Page Application) navigation you will need to import the `Link` component from `@tanstack/react-router`.

```tsx
import { Link } from "@tanstack/react-router";
```

Then anywhere in your JSX you can use it like so:

```tsx
<Link to="/about">About</Link>
```

This will create a link that will navigate to the `/about` route.

More information on the `Link` component can be found in the [Link documentation](https://tanstack.com/router/v1/docs/framework/react/api/router/linkComponent).

### Using A Layout

In the File Based Routing setup the layout is located in `src/routes/__root.tsx`. Anything you add to the root route will appear in all the routes. The route content will appear in the JSX where you use the `<Outlet />` component.

Here is an example layout that includes a header:

```tsx
import { Outlet, createRootRoute } from '@tanstack/react-router'
import { TanStackRouterDevtools } from '@tanstack/react-router-devtools'

import { Link } from "@tanstack/react-router";

export const Route = createRootRoute({
  component: () => (
    <>
      <header>
        <nav>
          <Link to="/">Home</Link>
          <Link to="/about">About</Link>
        </nav>
      </header>
      <Outlet />
      <TanStackRouterDevtools />
    </>
  ),
})
```

The `<TanStackRouterDevtools />` component is not required so you can remove it if you don't want it in your layout.

More information on layouts can be found in the [Layouts documentation](https://tanstack.com/router/latest/docs/framework/react/guide/routing-concepts#layouts).


## Data Fetching

There are multiple ways to fetch data in your application. You can use TanStack Query to fetch data from a server. But you can also use the `loader` functionality built into TanStack Router to load the data for a route before it's rendered.

For example:

```tsx
const peopleRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/people",
  loader: async () => {
    const response = await fetch("https://swapi.dev/api/people");
    return response.json() as Promise<{
      results: {
        name: string;
      }[];
    }>;
  },
  component: () => {
    const data = peopleRoute.useLoaderData();
    return (
      <ul>
        {data.results.map((person) => (
          <li key={person.name}>{person.name}</li>
        ))}
      </ul>
    );
  },
});
```

Loaders simplify your data fetching logic dramatically. Check out more information in the [Loader documentation](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#loader-parameters).

### React-Query

React-Query is an excellent addition or alternative to route loading and integrating it into you application is a breeze.

First add your dependencies:

```bash
npm install @tanstack/react-query @tanstack/react-query-devtools
```

Next we'll need to create a query client and provider. We recommend putting those in `main.tsx`.

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// ...

const queryClient = new QueryClient();

// ...

if (!rootElement.innerHTML) {
  const root = ReactDOM.createRoot(rootElement);

  root.render(
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  );
}
```

You can also add TanStack Query Devtools to the root route (optional).

```tsx
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

const rootRoute = createRootRoute({
  component: () => (
    <>
      <Outlet />
      <ReactQueryDevtools buttonPosition="top-right" />
      <TanStackRouterDevtools />
    </>
  ),
});
```

Now you can use `useQuery` to fetch your data.

```tsx
import { useQuery } from "@tanstack/react-query";

import "./App.css";

function App() {
  const { data } = useQuery({
    queryKey: ["people"],
    queryFn: () =>
      fetch("https://swapi.dev/api/people")
        .then((res) => res.json())
        .then((data) => data.results as { name: string }[]),
    initialData: [],
  });

  return (
    <div>
      <ul>
        {data.map((person) => (
          <li key={person.name}>{person.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

You can find out everything you need to know on how to use React-Query in the [React-Query documentation](https://tanstack.com/query/latest/docs/framework/react/overview).

## State Management

Another common requirement for React applications is state management. There are many options for state management in React. TanStack Store provides a great starting point for your project.

First you need to add TanStack Store as a dependency:

```bash
npm install @tanstack/store
```

Now let's create a simple counter in the `src/App.tsx` file as a demonstration.

```tsx
import { useStore } from "@tanstack/react-store";
import { Store } from "@tanstack/store";
import "./App.css";

const countStore = new Store(0);

function App() {
  const count = useStore(countStore);
  return (
    <div>
      <button onClick={() => countStore.setState((n) => n + 1)}>
        Increment - {count}
      </button>
    </div>
  );
}

export default App;
```

One of the many nice features of TanStack Store is the ability to derive state from other state. That derived state will update when the base state updates.

Let's check this out by doubling the count using derived state.

```tsx
import { useStore } from "@tanstack/react-store";
import { Store, Derived } from "@tanstack/store";
import "./App.css";

const countStore = new Store(0);

const doubledStore = new Derived({
  fn: () => countStore.state * 2,
  deps: [countStore],
});
doubledStore.mount();

function App() {
  const count = useStore(countStore);
  const doubledCount = useStore(doubledStore);

  return (
    <div>
      <button onClick={() => countStore.setState((n) => n + 1)}>
        Increment - {count}
      </button>
      <div>Doubled - {doubledCount}</div>
    </div>
  );
}

export default App;
```

We use the `Derived` class to create a new store that is derived from another store. The `Derived` class has a `mount` method that will start the derived store updating.

Once we've created the derived store we can use it in the `App` component just like we would any other store using the `useStore` hook.

You can find out everything you need to know on how to use TanStack Store in the [TanStack Store documentation](https://tanstack.com/store/latest).

# Demo files

Files prefixed with `demo` can be safely deleted. They are there to provide a starting point for you to play around with the features you've installed.

# Learn More

You can learn more about all of the offerings from TanStack in the [TanStack documentation](https://tanstack.com).



================================================
FILE: code/biome.json
================================================
{
	"$schema": "https://biomejs.dev/schemas/2.2.4/schema.json",
	"vcs": {
		"enabled": false,
		"clientKind": "git",
		"useIgnoreFile": false
	},
	"files": {
		"ignoreUnknown": false,
		"includes": [
			"**/src/**/*",
			"**/.vscode/**/*",
			"**/index.html",
			"**/vite.config.js",
			"!**/src/routeTree.gen.ts",
			"!**/src/styles.css"
		]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"assist": { "actions": { "source": { "organizeImports": "on" } } },
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	}
}



================================================
FILE: code/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/styles.css",
    "baseColor": "gray",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}



================================================
FILE: code/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-tsrouter-app"
    />
    <link rel="apple-touch-icon" href="/logo192.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>Create TanStack App - quickshop</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



================================================
FILE: code/package.json
================================================
{
  "name": "quickshop",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite --port 3000",
    "typecheck": "tsc",
    "build": "vite build && tsc",
    "preview": "vite preview",
    "test": "vitest run",
    "format": "biome format",
    "lint": "biome lint",
    "check": "biome check"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.13",
    "@supabase/supabase-js": "^2.93.2",
    "@tailwindcss/vite": "^4.0.6",
    "@tanstack/query-persist-client-core": "^5.91.19",
    "@tanstack/query-sync-storage-persister": "^5.90.22",
    "@tanstack/react-devtools": "^0.7.0",
    "@tanstack/react-query": "^5.66.5",
    "@tanstack/react-query-devtools": "^5.84.2",
    "@tanstack/react-query-persist-client": "^5.90.22",
    "@tanstack/react-router": "^1.132.0",
    "@tanstack/react-router-devtools": "^1.132.0",
    "@tanstack/router-plugin": "^1.132.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.545.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.71.1",
    "tailwind-merge": "^3.4.0",
    "tailwindcss": "^4.0.6"
  },
  "devDependencies": {
    "@biomejs/biome": "2.2.4",
    "@tanstack/devtools-vite": "^0.3.11",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/node": "^22.10.2",
    "@types/react": "^19.2.0",
    "@types/react-dom": "^19.2.0",
    "@vitejs/plugin-react": "^5.0.4",
    "jsdom": "^27.0.0",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5.7.2",
    "vite": "^7.1.7",
    "vitest": "^3.0.5",
    "web-vitals": "^5.1.0"
  }
}



================================================
FILE: code/tsconfig.json
================================================
{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}



================================================
FILE: code/vite.config.ts
================================================
/// <reference types="vitest/config" />
import { defineConfig } from 'vite'
import { devtools } from '@tanstack/devtools-vite'
import viteReact from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

import { tanstackRouter } from '@tanstack/router-plugin/vite'
import { fileURLToPath, URL } from 'node:url'

// https://vitejs.dev/config/
export default defineConfig({
  test: {
    passWithNoTests: true,
  },
  plugins: [
    devtools(),
    tanstackRouter({
      target: 'react',
      autoCodeSplitting: true,
    }),
    viteReact(),
    tailwindcss(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url)),
    },
  },
})



================================================
FILE: code/.cta.json
================================================
{
  "projectName": "quickshop",
  "mode": "file-router",
  "typescript": true,
  "tailwind": true,
  "packageManager": "npm",
  "addOnOptions": {},
  "git": true,
  "version": 1,
  "framework": "react-cra",
  "chosenAddOns": [
    "biome",
    "tanstack-query"
  ]
}


================================================
FILE: code/.env.local.template
================================================
VITE_SUPABASE_URL=<SUBSTITUTE_SUPABASE_URL>
VITE_SUPABASE_PUBLISHABLE_KEY=<SUBSTITUTE_SUPABASE_PUBLISHABLE_KEY>


================================================
FILE: code/public/manifest.json
================================================
{
  "short_name": "TanStack App",
  "name": "Create TanStack App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}



================================================
FILE: code/public/robots.txt
================================================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:



================================================
FILE: code/src/config.ts
================================================
export const cfg = {
	SUPABASE_URL: import.meta.env.VITE_SUPABASE_URL || "",
	SUPABASE_KEY: import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY || "",
};



================================================
FILE: code/src/main.tsx
================================================
import { createRouter, RouterProvider } from "@tanstack/react-router";
import { StrictMode } from "react";
import ReactDOM from "react-dom/client";

import * as TanStackQueryProvider from "./integrations/tanstack-query/root-provider.tsx";

// Import the generated route tree
import { routeTree } from "./routeTree.gen";

import "./styles.css";
import reportWebVitals from "./reportWebVitals.ts";

// Create a new router instance

const TanStackQueryProviderContext = TanStackQueryProvider.getContext();
const router = createRouter({
	routeTree,
	context: {
		...TanStackQueryProviderContext,
	},
	defaultPreload: "intent",
	scrollRestoration: true,
	defaultStructuralSharing: true,
	defaultPreloadStaleTime: 0,
});

// Register the router instance for type safety
declare module "@tanstack/react-router" {
	interface Register {
		router: typeof router;
	}
}

// Render the app
const rootElement = document.getElementById("app");
if (rootElement && !rootElement.innerHTML) {
	const root = ReactDOM.createRoot(rootElement);
	root.render(
		<StrictMode>
			<TanStackQueryProvider.Provider {...TanStackQueryProviderContext}>
				<RouterProvider router={router} />
			</TanStackQueryProvider.Provider>
		</StrictMode>,
	);
}

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();



================================================
FILE: code/src/reportWebVitals.ts
================================================
const reportWebVitals = (onPerfEntry?: () => void) => {
	if (onPerfEntry && onPerfEntry instanceof Function) {
		import("web-vitals").then(({ onCLS, onINP, onFCP, onLCP, onTTFB }) => {
			onCLS(onPerfEntry);
			onINP(onPerfEntry);
			onFCP(onPerfEntry);
			onLCP(onPerfEntry);
			onTTFB(onPerfEntry);
		});
	}
};

export default reportWebVitals;



================================================
FILE: code/src/routeTree.gen.ts
================================================
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Route as rootRouteImport } from './routes/__root'
import { Route as SetsRouteImport } from './routes/sets'
import { Route as ListsRouteImport } from './routes/lists'
import { Route as HistoryRouteImport } from './routes/history'
import { Route as AuthRouteImport } from './routes/auth'
import { Route as IndexRouteImport } from './routes/index'
import { Route as SetsIndexRouteImport } from './routes/sets.index'
import { Route as ListsIndexRouteImport } from './routes/lists.index'
import { Route as SetsSetIdRouteImport } from './routes/sets.$setId'
import { Route as ListsListIdRouteImport } from './routes/lists.$listId'
import { Route as DemoTanstackQueryRouteImport } from './routes/demo/tanstack-query'

const SetsRoute = SetsRouteImport.update({
  id: '/sets',
  path: '/sets',
  getParentRoute: () => rootRouteImport,
} as any)
const ListsRoute = ListsRouteImport.update({
  id: '/lists',
  path: '/lists',
  getParentRoute: () => rootRouteImport,
} as any)
const HistoryRoute = HistoryRouteImport.update({
  id: '/history',
  path: '/history',
  getParentRoute: () => rootRouteImport,
} as any)
const AuthRoute = AuthRouteImport.update({
  id: '/auth',
  path: '/auth',
  getParentRoute: () => rootRouteImport,
} as any)
const IndexRoute = IndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRouteImport,
} as any)
const SetsIndexRoute = SetsIndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => SetsRoute,
} as any)
const ListsIndexRoute = ListsIndexRouteImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => ListsRoute,
} as any)
const SetsSetIdRoute = SetsSetIdRouteImport.update({
  id: '/$setId',
  path: '/$setId',
  getParentRoute: () => SetsRoute,
} as any)
const ListsListIdRoute = ListsListIdRouteImport.update({
  id: '/$listId',
  path: '/$listId',
  getParentRoute: () => ListsRoute,
} as any)
const DemoTanstackQueryRoute = DemoTanstackQueryRouteImport.update({
  id: '/demo/tanstack-query',
  path: '/demo/tanstack-query',
  getParentRoute: () => rootRouteImport,
} as any)

export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/auth': typeof AuthRoute
  '/history': typeof HistoryRoute
  '/lists': typeof ListsRouteWithChildren
  '/sets': typeof SetsRouteWithChildren
  '/demo/tanstack-query': typeof DemoTanstackQueryRoute
  '/lists/$listId': typeof ListsListIdRoute
  '/sets/$setId': typeof SetsSetIdRoute
  '/lists/': typeof ListsIndexRoute
  '/sets/': typeof SetsIndexRoute
}
export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/auth': typeof AuthRoute
  '/history': typeof HistoryRoute
  '/demo/tanstack-query': typeof DemoTanstackQueryRoute
  '/lists/$listId': typeof ListsListIdRoute
  '/sets/$setId': typeof SetsSetIdRoute
  '/lists': typeof ListsIndexRoute
  '/sets': typeof SetsIndexRoute
}
export interface FileRoutesById {
  __root__: typeof rootRouteImport
  '/': typeof IndexRoute
  '/auth': typeof AuthRoute
  '/history': typeof HistoryRoute
  '/lists': typeof ListsRouteWithChildren
  '/sets': typeof SetsRouteWithChildren
  '/demo/tanstack-query': typeof DemoTanstackQueryRoute
  '/lists/$listId': typeof ListsListIdRoute
  '/sets/$setId': typeof SetsSetIdRoute
  '/lists/': typeof ListsIndexRoute
  '/sets/': typeof SetsIndexRoute
}
export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/'
    | '/auth'
    | '/history'
    | '/lists'
    | '/sets'
    | '/demo/tanstack-query'
    | '/lists/$listId'
    | '/sets/$setId'
    | '/lists/'
    | '/sets/'
  fileRoutesByTo: FileRoutesByTo
  to:
    | '/'
    | '/auth'
    | '/history'
    | '/demo/tanstack-query'
    | '/lists/$listId'
    | '/sets/$setId'
    | '/lists'
    | '/sets'
  id:
    | '__root__'
    | '/'
    | '/auth'
    | '/history'
    | '/lists'
    | '/sets'
    | '/demo/tanstack-query'
    | '/lists/$listId'
    | '/sets/$setId'
    | '/lists/'
    | '/sets/'
  fileRoutesById: FileRoutesById
}
export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  AuthRoute: typeof AuthRoute
  HistoryRoute: typeof HistoryRoute
  ListsRoute: typeof ListsRouteWithChildren
  SetsRoute: typeof SetsRouteWithChildren
  DemoTanstackQueryRoute: typeof DemoTanstackQueryRoute
}

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/sets': {
      id: '/sets'
      path: '/sets'
      fullPath: '/sets'
      preLoaderRoute: typeof SetsRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/lists': {
      id: '/lists'
      path: '/lists'
      fullPath: '/lists'
      preLoaderRoute: typeof ListsRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/history': {
      id: '/history'
      path: '/history'
      fullPath: '/history'
      preLoaderRoute: typeof HistoryRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/auth': {
      id: '/auth'
      path: '/auth'
      fullPath: '/auth'
      preLoaderRoute: typeof AuthRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexRouteImport
      parentRoute: typeof rootRouteImport
    }
    '/sets/': {
      id: '/sets/'
      path: '/'
      fullPath: '/sets/'
      preLoaderRoute: typeof SetsIndexRouteImport
      parentRoute: typeof SetsRoute
    }
    '/lists/': {
      id: '/lists/'
      path: '/'
      fullPath: '/lists/'
      preLoaderRoute: typeof ListsIndexRouteImport
      parentRoute: typeof ListsRoute
    }
    '/sets/$setId': {
      id: '/sets/$setId'
      path: '/$setId'
      fullPath: '/sets/$setId'
      preLoaderRoute: typeof SetsSetIdRouteImport
      parentRoute: typeof SetsRoute
    }
    '/lists/$listId': {
      id: '/lists/$listId'
      path: '/$listId'
      fullPath: '/lists/$listId'
      preLoaderRoute: typeof ListsListIdRouteImport
      parentRoute: typeof ListsRoute
    }
    '/demo/tanstack-query': {
      id: '/demo/tanstack-query'
      path: '/demo/tanstack-query'
      fullPath: '/demo/tanstack-query'
      preLoaderRoute: typeof DemoTanstackQueryRouteImport
      parentRoute: typeof rootRouteImport
    }
  }
}

interface ListsRouteChildren {
  ListsListIdRoute: typeof ListsListIdRoute
  ListsIndexRoute: typeof ListsIndexRoute
}

const ListsRouteChildren: ListsRouteChildren = {
  ListsListIdRoute: ListsListIdRoute,
  ListsIndexRoute: ListsIndexRoute,
}

const ListsRouteWithChildren = ListsRoute._addFileChildren(ListsRouteChildren)

interface SetsRouteChildren {
  SetsSetIdRoute: typeof SetsSetIdRoute
  SetsIndexRoute: typeof SetsIndexRoute
}

const SetsRouteChildren: SetsRouteChildren = {
  SetsSetIdRoute: SetsSetIdRoute,
  SetsIndexRoute: SetsIndexRoute,
}

const SetsRouteWithChildren = SetsRoute._addFileChildren(SetsRouteChildren)

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  AuthRoute: AuthRoute,
  HistoryRoute: HistoryRoute,
  ListsRoute: ListsRouteWithChildren,
  SetsRoute: SetsRouteWithChildren,
  DemoTanstackQueryRoute: DemoTanstackQueryRoute,
}
export const routeTree = rootRouteImport
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()



================================================
FILE: code/src/styles.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

body {
  @apply m-0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.13 0.028 261.692);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.13 0.028 261.692);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.13 0.028 261.692);
  --primary: oklch(0.21 0.034 264.665);
  --primary-foreground: oklch(0.985 0.002 247.839);
  --secondary: oklch(0.967 0.003 264.542);
  --secondary-foreground: oklch(0.21 0.034 264.665);
  --muted: oklch(0.967 0.003 264.542);
  --muted-foreground: oklch(0.551 0.027 264.364);
  --accent: oklch(0.967 0.003 264.542);
  --accent-foreground: oklch(0.21 0.034 264.665);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.928 0.006 264.531);
  --input: oklch(0.928 0.006 264.531);
  --ring: oklch(0.707 0.022 261.325);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0.002 247.839);
  --sidebar-foreground: oklch(0.13 0.028 261.692);
  --sidebar-primary: oklch(0.21 0.034 264.665);
  --sidebar-primary-foreground: oklch(0.985 0.002 247.839);
  --sidebar-accent: oklch(0.967 0.003 264.542);
  --sidebar-accent-foreground: oklch(0.21 0.034 264.665);
  --sidebar-border: oklch(0.928 0.006 264.531);
  --sidebar-ring: oklch(0.707 0.022 261.325);
}

.dark {
  --background: oklch(0.13 0.028 261.692);
  --foreground: oklch(0.985 0.002 247.839);
  --card: oklch(0.21 0.034 264.665);
  --card-foreground: oklch(0.985 0.002 247.839);
  --popover: oklch(0.21 0.034 264.665);
  --popover-foreground: oklch(0.985 0.002 247.839);
  --primary: oklch(0.928 0.006 264.531);
  --primary-foreground: oklch(0.21 0.034 264.665);
  --secondary: oklch(0.278 0.033 256.848);
  --secondary-foreground: oklch(0.985 0.002 247.839);
  --muted: oklch(0.278 0.033 256.848);
  --muted-foreground: oklch(0.707 0.022 261.325);
  --accent: oklch(0.278 0.033 256.848);
  --accent-foreground: oklch(0.985 0.002 247.839);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.034 264.665);
  --sidebar-foreground: oklch(0.985 0.002 247.839);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0.002 247.839);
  --sidebar-accent: oklch(0.278 0.033 256.848);
  --sidebar-accent-foreground: oklch(0.985 0.002 247.839);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

.pb-safe-area-bottom {
  padding-bottom: env(safe-area-inset-bottom, 1rem);
}



================================================
FILE: code/src/components/Header.tsx
================================================
import { useNavigate, useRouterState } from "@tanstack/react-router";
import { LogOut, User } from "lucide-react";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import { supabaseClient } from "@/db/supabase.client";

function getTitle(pathname: string): string {
	if (pathname === "/sets" || pathname.startsWith("/sets/")) return "Zestawy";
	if (pathname === "/lists" || pathname.startsWith("/lists")) return "Listy";
	if (pathname === "/history") return "Historia";
	return "QuickShop";
}

export default function Header() {
	const [open, setOpen] = useState(false);
	const navigate = useNavigate();
	const pathname = useRouterState({ select: (s) => s.location.pathname });
	const title = getTitle(pathname);
	const isSetsRoute =
		pathname === "/sets" || pathname.startsWith("/sets/");

	const handleLogout = async () => {
		await supabaseClient.auth.signOut();
		setOpen(false);
		navigate({ to: "/auth" });
	};

	return (
		<header
			className={cn(
				"sticky top-0 z-30 flex items-center justify-between border-b bg-background px-4 py-3",
				isSetsRoute && "border-primary/30 bg-primary/5",
			)}
		>
			<h1 className="text-lg font-semibold">{title}</h1>
			<DropdownMenu open={open} onOpenChange={setOpen}>
				<DropdownMenuTrigger asChild>
					<Button variant="ghost" size="icon" aria-label="Menu użytkownika">
						<User className="h-5 w-5" />
					</Button>
				</DropdownMenuTrigger>
				<DropdownMenuContent align="end">
					<DropdownMenuItem onClick={handleLogout}>
						<LogOut className="mr-2 h-4 w-4" />
						Wyloguj się
					</DropdownMenuItem>
				</DropdownMenuContent>
			</DropdownMenu>
		</header>
	);
}



================================================
FILE: code/src/components/auth/AuthModeSwitch.tsx
================================================
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import type { AuthMode } from "@/types/auth.types";

interface AuthModeSwitchProps {
	currentMode: AuthMode;
	onModeChange: (mode: AuthMode) => void;
}

export function AuthModeSwitch({
	currentMode,
	onModeChange,
}: AuthModeSwitchProps) {
	return (
		<Tabs
			value={currentMode}
			onValueChange={(value) => onModeChange(value as AuthMode)}
		>
			<TabsList className="grid w-full grid-cols-2">
				<TabsTrigger value="signin">Logowanie</TabsTrigger>
				<TabsTrigger value="signup">Rejestracja</TabsTrigger>
			</TabsList>
		</Tabs>
	);
}



================================================
FILE: code/src/components/auth/EmailAuthForm.tsx
================================================
import { zodResolver } from "@hookform/resolvers/zod";
import { Loader2 } from "lucide-react";
import { useId } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { AuthCredentials, AuthMode } from "@/types/auth.types";

const authSchema = z.object({
	email: z.string().email("Nieprawidłowy format email"),
	pass: z.string().min(6, "Hasło musi mieć minimum 6 znaków"),
});

interface EmailAuthFormProps {
	mode: AuthMode;
	onSubmit: (credentials: AuthCredentials) => Promise<void>;
	isLoading: boolean;
}

export function EmailAuthForm({
	mode,
	onSubmit,
	isLoading,
}: EmailAuthFormProps) {
	const emailId = useId();
	const passwordId = useId();

	const {
		register,
		handleSubmit,
		formState: { errors },
	} = useForm<AuthCredentials>({
		resolver: zodResolver(authSchema),
	});

	const buttonText = mode === "signin" ? "Zaloguj się" : "Zarejestruj się";
	const titleText = mode === "signin" ? "Logowanie" : "Rejestracja";

	return (
		<form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
			<div className="space-y-2">
				<h2 className="text-2xl font-semibold text-center">{titleText}</h2>
			</div>

			<div className="space-y-2">
				<Label htmlFor={emailId}>Email</Label>
				<Input
					id={emailId}
					type="email"
					placeholder="twoj@email.com"
					disabled={isLoading}
					{...register("email")}
				/>
				{errors.email && (
					<p className="text-sm text-red-500">{errors.email.message}</p>
				)}
			</div>

			<div className="space-y-2">
				<Label htmlFor={passwordId}>Hasło</Label>
				<Input
					id={passwordId}
					type="password"
					placeholder="••••••••"
					disabled={isLoading}
					{...register("pass")}
				/>
				{errors.pass && (
					<p className="text-sm text-red-500">{errors.pass.message}</p>
				)}
			</div>

			<Button type="submit" className="w-full" disabled={isLoading}>
				{isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
				{isLoading
					? mode === "signin"
						? "Logowanie..."
						: "Rejestracja..."
					: buttonText}
			</Button>
		</form>
	);
}



================================================
FILE: code/src/components/auth/GoogleAuthButton.tsx
================================================
import { Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";

interface GoogleAuthButtonProps {
	onClick: () => Promise<void>;
	isLoading: boolean;
}

export function GoogleAuthButton({
	onClick,
	isLoading,
}: GoogleAuthButtonProps) {
	return (
		<Button
			type="button"
			variant="outline"
			className="w-full"
			onClick={onClick}
			disabled={isLoading}
		>
			{isLoading ? (
				<>
					<Loader2 className="mr-2 h-4 w-4 animate-spin" />
					Logowanie...
				</>
			) : (
				<svg
					className="mr-2 h-4 w-4"
					viewBox="0 0 24 24"
					aria-label="Google logo"
				>
					<title>Google</title>
					<path
						fill="currentColor"
						d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
					/>
					<path
						fill="currentColor"
						d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
					/>
					<path
						fill="currentColor"
						d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
					/>
					<path
						fill="currentColor"
						d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
					/>
				</svg>
			)}
			{!isLoading && "Zaloguj z Google"}
		</Button>
	);
}



================================================
FILE: code/src/components/layout/BottomNav.tsx
================================================
import { Link, useRouterState } from "@tanstack/react-router";
import { History, Layers, ListTodo } from "lucide-react";

const navItems = [
	{ to: "/lists", label: "Listy", icon: ListTodo },
	{ to: "/sets", label: "Zestawy", icon: Layers },
	{ to: "/history", label: "Historia", icon: History },
] as const;

export function BottomNav() {
	const pathname = useRouterState({ select: (s) => s.location.pathname });

	return (
		<nav
			className="fixed bottom-0 left-0 right-0 z-40 border-t bg-background pb-[env(safe-area-inset-bottom)]"
			aria-label="Główna nawigacja"
		>
			<div className="container mx-auto flex max-w-md justify-around">
				{navItems.map(({ to, label, icon: Icon }) => {
					const isCurrent =
						pathname === to ||
						(to === "/sets" && pathname.startsWith("/sets/"));
					return (
						<Link
							key={to}
							to={to}
							className={`flex flex-col items-center gap-1 py-3 px-4 text-xs transition-colors ${
								isCurrent
									? "text-primary font-medium"
									: "text-muted-foreground hover:text-foreground"
							}`}
						>
							<Icon className="h-6 w-6" aria-hidden />
							<span>{label}</span>
						</Link>
					);
				})}
			</div>
		</nav>
	);
}



================================================
FILE: code/src/components/layout/MainLayout.tsx
================================================
import { useRouterState } from "@tanstack/react-router";
import type { ReactNode } from "react";
import Header from "@/components/Header";
import { BottomNav } from "./BottomNav";

const DASHBOARD_PATHS = ["/lists", "/sets", "/history"] as const;

function useShowAppChrome() {
	const pathname = useRouterState({ select: (s) => s.location.pathname });
	const isDashboard = DASHBOARD_PATHS.some((p) => pathname === p);
	return { showHeader: isDashboard, showBottomNav: isDashboard };
}

interface MainLayoutProps {
	children: ReactNode;
}

export function MainLayout({ children }: MainLayoutProps) {
	const { showHeader, showBottomNav } = useShowAppChrome();

	return (
		<>
			{showHeader && <Header />}
			<main className="container mx-auto max-w-md min-h-screen px-4 pb-24">
				{children}
			</main>
			{showBottomNav && <BottomNav />}
		</>
	);
}



================================================
FILE: code/src/components/list-details/ActiveItemsList.tsx
================================================
import {
	DndContext,
	type DragEndEvent,
	PointerSensor,
	useSensor,
	useSensors,
	closestCenter,
} from "@dnd-kit/core";
import {
	SortableContext,
	arrayMove,
	useSortable,
	verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import type { ListItem } from "@/types/domain.types";
import { ListItemRow } from "./ListItemRow";

interface ActiveItemsListProps {
	items: ListItem[];
	onToggle: (id: string, isCompleted: boolean) => void;
	onDelete: (id: string) => void;
	onReorder?: (orderedItems: ListItem[]) => void;
	pendingIds?: Set<string>;
}

function SortableRow({
	item,
	onToggle,
	onDelete,
	pendingIds,
}: {
	item: ListItem;
	onToggle: (id: string, isCompleted: boolean) => void;
	onDelete: (id: string) => void;
	pendingIds: Set<string>;
}) {
	const {
		attributes,
		listeners,
		setNodeRef,
		setActivatorNodeRef,
		transform,
		transition,
		isDragging,
	} = useSortable({ id: item.id });

	const style = {
		transform: CSS.Transform.toString(transform),
		transition,
	};

	return (
		<div ref={setNodeRef} style={style}>
			<ListItemRow
				item={item}
				onToggle={onToggle}
				onDelete={onDelete}
				isPending={pendingIds.has(item.id)}
				dragHandleProps={{
					attributes: attributes as unknown as Record<string, unknown>,
					listeners: (listeners ?? {}) as unknown as Record<string, unknown>,
					setActivatorNodeRef,
				}}
				isDragging={isDragging}
			/>
		</div>
	);
}

export function ActiveItemsList({
	items,
	onToggle,
	onDelete,
	onReorder,
	pendingIds = new Set(),
}: ActiveItemsListProps) {
	const sensors = useSensors(
		useSensor(PointerSensor, {
			activationConstraint: { distance: 8 },
		}),
	);

	const handleDragEnd = (event: DragEndEvent) => {
		const { active, over } = event;
		if (!over || active.id === over.id || !onReorder) return;
		const oldIndex = items.findIndex((i) => i.id === active.id);
		const overIndex = items.findIndex((i) => i.id === over.id);
		if (oldIndex === -1 || overIndex === -1) return;
		const reordered = arrayMove(items, oldIndex, overIndex);
		onReorder(reordered);
	};

	if (items.length === 0) {
		return (
			<div className="text-center py-10 text-muted-foreground">
				Lista jest pusta. Dodaj produkty poniżej.
			</div>
		);
	}

	const itemIds = items.map((i) => i.id);

	return (
		<DndContext
			sensors={sensors}
			collisionDetection={closestCenter}
			onDragEnd={handleDragEnd}
		>
			<SortableContext
				items={itemIds}
				strategy={verticalListSortingStrategy}
			>
				<div className="p-4 pb-0">
					{items.map((item) => (
						<SortableRow
							key={item.id}
							item={item}
							onToggle={onToggle}
							onDelete={onDelete}
							pendingIds={pendingIds}
						/>
					))}
				</div>
			</SortableContext>
		</DndContext>
	);
}



================================================
FILE: code/src/components/list-details/CompletedItemsSection.tsx
================================================
import { Separator } from "@/components/ui/separator";
import type { ListItem } from "@/types/domain.types";
import { ListItemRow } from "./ListItemRow";

interface CompletedItemsSectionProps {
	items: ListItem[];
	onToggle: (id: string, isCompleted: boolean) => void;
	onDelete: (id: string) => void;
	pendingIds?: Set<string>;
}

export function CompletedItemsSection({
	items,
	onToggle,
	onDelete,
	pendingIds = new Set(),
}: CompletedItemsSectionProps) {
	if (items.length === 0) return null;

	return (
		<div className="p-4 pt-2">
			<div className="flex items-center gap-4 my-4">
				<Separator className="flex-1" />
				<span className="text-sm text-muted-foreground font-medium">
					Kupione ({items.length})
				</span>
				<Separator className="flex-1" />
			</div>
			{items.map((item) => (
				<ListItemRow
					key={item.id}
					item={item}
					onToggle={onToggle}
					onDelete={onDelete}
					isPending={pendingIds.has(item.id)}
				/>
			))}
		</div>
	);
}



================================================
FILE: code/src/components/list-details/ItemConflictDialog.tsx
================================================
import { useEffect, useId, useState } from "react";
import { Button } from "@/components/ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { ListItem } from "@/types/domain.types";

interface ItemConflictDialogProps {
	isOpen: boolean;
	existingItem?: ListItem;
	newItemName?: string;
	onConfirm: (combinedQuantity: string) => void;
	onCancel: () => void;
}

export function ItemConflictDialog({
	isOpen,
	existingItem,
	newItemName,
	onConfirm,
	onCancel,
}: ItemConflictDialogProps) {
	const [quantity, setQuantity] = useState("");
	const quantityId = useId();

	useEffect(() => {
		if (isOpen && existingItem) {
			setQuantity(existingItem.quantity || "");
		}
	}, [isOpen, existingItem]);

	const handleConfirm = () => {
		onConfirm(quantity);
	};

	return (
		<Dialog open={isOpen} onOpenChange={(open) => !open && onCancel()}>
			<DialogContent>
				<DialogHeader>
					<DialogTitle>Produkt już istnieje</DialogTitle>
					<DialogDescription>
						"{newItemName}" jest już na liście. Czy chcesz zaktualizować ilość?
					</DialogDescription>
				</DialogHeader>
				<div className="grid gap-4 py-4">
					<div className="grid gap-2">
						<Label htmlFor={quantityId}>Ilość</Label>
						<Input
							id={quantityId}
							value={quantity}
							onChange={(e) => setQuantity(e.target.value)}
							placeholder="np. 1 szt + 2 op"
						/>
					</div>
				</div>
				<DialogFooter>
					<Button variant="outline" onClick={onCancel}>
						Anuluj
					</Button>
					<Button onClick={handleConfirm}>Zaktualizuj</Button>
				</DialogFooter>
			</DialogContent>
		</Dialog>
	);
}



================================================
FILE: code/src/components/list-details/ListDetailsHeader.tsx
================================================
import { Link } from "@tanstack/react-router";
import {
	Archive,
	ArrowLeft,
	Copy,
	MoreVertical,
	Pencil,
	Share2,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuLabel,
	DropdownMenuSeparator,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import type { ShoppingList } from "@/types/domain.types";

interface ListDetailsHeaderProps {
	list: ShoppingList;
	onShare: () => void;
	onArchive: () => void;
	onCreateSet: () => void;
	onRename?: () => void;
}

export function ListDetailsHeader({
	list,
	onShare,
	onArchive,
	onCreateSet,
	onRename,
}: ListDetailsHeaderProps) {
	return (
		<div className="flex items-center justify-between p-4 border-b bg-background sticky top-0 z-10">
			<div className="flex items-center gap-3 min-w-0 flex-1">
				<Link
					to="/lists"
					className="p-2 -ml-2 hover:bg-accent rounded-full shrink-0"
					aria-label="Wróć do list"
				>
					<ArrowLeft className="h-5 w-5" />
				</Link>
				<div className="min-w-0 flex-1">
					<h1 className="font-semibold text-lg leading-tight truncate">
						{list.name}
					</h1>
					{/* SyncStatusIndicator – placeholder (część 9) */}
					<div
						className="h-1 w-4 mt-0.5"
						aria-hidden
						title="Status synchronizacji – wkrótce"
					/>
				</div>
			</div>

			<DropdownMenu>
				<DropdownMenuTrigger asChild>
					<Button variant="ghost" size="icon">
						<MoreVertical className="h-5 w-5" />
					</Button>
				</DropdownMenuTrigger>
				<DropdownMenuContent align="end">
					<DropdownMenuLabel>Opcje listy</DropdownMenuLabel>
					<DropdownMenuSeparator />
					<DropdownMenuItem onClick={onShare}>
						<Share2 className="mr-2 h-4 w-4" />
						Udostępnij
					</DropdownMenuItem>
					<DropdownMenuItem onClick={onCreateSet}>
						<Copy className="mr-2 h-4 w-4" />
						Utwórz zestaw
					</DropdownMenuItem>
					{onRename && (
						<DropdownMenuItem onClick={onRename}>
							<Pencil className="mr-2 h-4 w-4" />
							Zmień nazwę
						</DropdownMenuItem>
					)}
					<DropdownMenuSeparator />
					<DropdownMenuItem
						onClick={onArchive}
						className="text-destructive focus:text-destructive"
					>
						<Archive className="mr-2 h-4 w-4" />
						Zakończ zakupy (Archiwizuj)
					</DropdownMenuItem>
				</DropdownMenuContent>
			</DropdownMenu>
		</div>
	);
}



================================================
FILE: code/src/components/list-details/ListItemRow.tsx
================================================
import { GripVertical, MoreVertical, Trash2 } from "lucide-react";
import { Checkbox } from "@/components/ui/checkbox";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import type { ListItem } from "@/types/domain.types";

interface ListItemRowProps {
	item: ListItem;
	onToggle: (id: string, isCompleted: boolean) => void;
	onDelete: (id: string) => void;
	/** Elementy niesynchronizowane – obniżona opacity (optimistic UI) */
	isPending?: boolean;
	/** Opcjonalne atrybuty i listenery dla drag handle (drag-and-drop) */
	dragHandleProps?: {
		attributes?: Record<string, unknown>;
		listeners?: Record<string, unknown>;
		setActivatorNodeRef?: (element: HTMLElement | null) => void;
	};
	/** Czy wiersz jest właśnie przeciągany */
	isDragging?: boolean;
}

export function ListItemRow({
	item,
	onToggle,
	onDelete,
	isPending = false,
	dragHandleProps,
	isDragging = false,
}: ListItemRowProps) {
	const grip = (
		<div
			ref={dragHandleProps?.setActivatorNodeRef}
			className="text-muted-foreground cursor-grab active:cursor-grabbing shrink-0 touch-none"
			aria-hidden
			{...(dragHandleProps?.attributes ?? {})}
			{...(dragHandleProps?.listeners ?? {})}
		>
			<GripVertical className="h-4 w-4" />
		</div>
	);

	return (
		<div
			className={cn(
				"flex items-center gap-3 p-3 bg-card border rounded-lg mb-2 transition-opacity",
				item.is_bought && "opacity-60 bg-muted/50",
				isPending && "opacity-70",
				isDragging && "opacity-80 shadow-md z-10",
			)}
		>
			<Checkbox
				checked={item.is_bought ?? false}
				onCheckedChange={(checked) => onToggle(item.id, checked === true)}
			/>

			<div className="flex-1 min-w-0">
				<div
					className={cn(
						"font-medium truncate",
						item.is_bought && "line-through text-muted-foreground",
					)}
				>
					{item.name}
				</div>
				{(item.quantity || item.note) && (
					<div className="text-sm text-muted-foreground truncate">
						{[item.quantity, item.note].filter(Boolean).join(" · ")}
					</div>
				)}
			</div>

			{grip}

			<DropdownMenu>
				<DropdownMenuTrigger asChild>
					<button
						type="button"
						className="p-2 rounded-md hover:bg-muted text-muted-foreground hover:text-foreground transition-colors"
						aria-label="Otwórz menu pozycji"
					>
						<MoreVertical className="h-4 w-4" />
					</button>
				</DropdownMenuTrigger>
				<DropdownMenuContent align="end">
					<DropdownMenuItem
						className="text-destructive focus:text-destructive"
						onSelect={() => onDelete(item.id)}
					>
						<Trash2 className="mr-2 h-4 w-4" />
						Usuń
					</DropdownMenuItem>
				</DropdownMenuContent>
			</DropdownMenu>
		</div>
	);
}



================================================
FILE: code/src/components/list-details/SetConflictResolutionDialog.tsx
================================================
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import type {
	CreateListItemDTO,
	SetConflictItem,
	SetResolutionResult,
} from "@/types/domain.types";

interface SetConflictResolutionDialogProps {
	isOpen: boolean;
	conflicts: SetConflictItem[];
	nonConflictingItems: CreateListItemDTO[];
	onResolve: (resolution: SetResolutionResult) => void;
	onCancel: () => void;
}

export function SetConflictResolutionDialog({
	isOpen,
	conflicts,
	nonConflictingItems,
	onResolve,
	onCancel,
}: SetConflictResolutionDialogProps) {
	const [selectedConflicts, setSelectedConflicts] = useState<Set<string>>(
		new Set(),
	);

	const handleToggle = (itemName: string) => {
		const next = new Set(selectedConflicts);
		if (next.has(itemName)) {
			next.delete(itemName);
		} else {
			next.add(itemName);
		}
		setSelectedConflicts(next);
	};

	const handleConfirm = () => {
		const itemsToUpdate: { itemId: string; newQuantity: string }[] = [];

		// Process conflicts
		conflicts.forEach((conflict) => {
			if (selectedConflicts.has(conflict.existingItem.name)) {
				// User chose to update/merge
				itemsToUpdate.push({
					itemId: conflict.existingItem.id,
					newQuantity: conflict.suggestedQuantity,
				});
			}
		});

		onResolve({
			itemsToCreate: nonConflictingItems,
			itemsToUpdate,
		});
	};

	return (
		<Dialog open={isOpen} onOpenChange={(open) => !open && onCancel()}>
			<DialogContent className="max-w-md">
				<DialogHeader>
					<DialogTitle>Znaleziono duplikaty</DialogTitle>
					<DialogDescription>
						Poniższe produkty już są na liście. Zaznacz te, dla których chcesz
						zsumować ilości. Niezaznaczone produkty pozostaną bez zmian.
					</DialogDescription>
				</DialogHeader>

				<div className="max-h-[60vh] overflow-y-auto py-4">
					{conflicts.map((conflict) => (
						<div
							key={conflict.existingItem.id}
							className="flex items-start gap-3 mb-4 p-3 border rounded-md"
						>
							<Checkbox
								checked={selectedConflicts.has(conflict.existingItem.name)}
								onCheckedChange={() => handleToggle(conflict.existingItem.name)}
							/>
							<div>
								<div className="font-medium">{conflict.existingItem.name}</div>
								<div className="text-sm text-muted-foreground">
									Obecnie: {conflict.existingItem.quantity || "0"} <br />
									Dodawane: {conflict.newItemCandidate.quantity || "0"} <br />
									<span className="text-primary font-semibold">
										Po złączeniu: {conflict.suggestedQuantity}
									</span>
								</div>
							</div>
						</div>
					))}
				</div>

				<DialogFooter>
					<Button variant="outline" onClick={onCancel}>
						Anuluj
					</Button>
					<Button onClick={handleConfirm}>
						Dodaj ({nonConflictingItems.length + selectedConflicts.size} prod.)
					</Button>
				</DialogFooter>
			</DialogContent>
		</Dialog>
	);
}



================================================
FILE: code/src/components/list-details/StickyInputBar.tsx
================================================
import { Plus } from "lucide-react";
import { useId, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { cn } from "@/lib/utils";

interface StickyInputBarProps {
	onAddItem: (name: string) => void;
	isSubmitting: boolean;
}

export function StickyInputBar({
	onAddItem,
	isSubmitting,
}: StickyInputBarProps) {
	const errorId = useId();
	const [value, setValue] = useState("");
	const [showError, setShowError] = useState(false);

	const handleSubmit = (e: React.FormEvent) => {
		e.preventDefault();
		const trimmed = value.trim();
		if (!trimmed) {
			setShowError(true);
			setTimeout(() => setShowError(false), 600);
			return;
		}
		setShowError(false);
		onAddItem(trimmed);
		setValue("");
	};

	return (
		<div className="sticky bottom-0 left-0 right-0 bg-background border-t p-4 pb-safe-area-bottom">
			<form
				onSubmit={handleSubmit}
				className="flex gap-2 max-w-screen-md mx-auto"
			>
				<Input
					value={value}
					onChange={(e) => {
						setValue(e.target.value);
						if (showError) setShowError(false);
					}}
					placeholder="Dodaj produkt..."
					disabled={isSubmitting}
					className={cn(
						"flex-1 transition-[box-shadow] duration-150",
						showError &&
							"animate-pulse border-destructive ring-2 ring-destructive/30",
					)}
					maxLength={100}
					aria-invalid={showError}
					aria-describedby={showError ? errorId : undefined}
				/>
				<Button
					type="submit"
					size="icon"
					disabled={isSubmitting || !value.trim()}
					aria-label="Dodaj produkt"
				>
					<Plus className="h-5 w-5" />
				</Button>
			</form>
			{showError && (
				<p id={errorId} className="text-sm text-destructive mt-1" role="alert">
					Wpisz nazwę produktu
				</p>
			)}
		</div>
	);
}



================================================
FILE: code/src/components/lists/CreateListDialog.tsx
================================================
import { type FormEvent, useId, useState } from "react";
import { Button } from "@/components/ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { CreateListDTO } from "@/types/domain.types";

interface CreateListDialogProps {
	isOpen: boolean;
	onClose: () => void;
	onCreateList: (data: CreateListDTO) => Promise<void>;
	isCreating: boolean;
}

/**
 * Dialog component for creating a new shopping list.
 * Includes form validation and error handling.
 */
export function CreateListDialog({
	isOpen,
	onClose,
	onCreateList,
	isCreating,
}: CreateListDialogProps) {
	const [name, setName] = useState("");
	const [error, setError] = useState<string | null>(null);
	const listNameId = useId();

	// Validation
	const isNameValid = name.trim().length > 0 && name.trim().length <= 100;

	const handleSubmit = async (e: FormEvent) => {
		e.preventDefault();

		// Client-side validation
		const trimmedName = name.trim();

		if (!trimmedName) {
			setError("Nazwa listy jest wymagana");
			return;
		}

		if (trimmedName.length > 100) {
			setError("Nazwa listy może mieć maksymalnie 100 znaków");
			return;
		}

		// Clear error and submit
		setError(null);

		try {
			await onCreateList({ name: trimmedName });
			// Reset form on success
			setName("");
			setError(null);
		} catch (err) {
			setError(
				err instanceof Error
					? err.message
					: "Nie udało się utworzyć listy. Spróbuj ponownie.",
			);
		}
	};

	const handleClose = () => {
		// Reset form when closing
		setName("");
		setError(null);
		onClose();
	};

	const handleNameChange = (value: string) => {
		setName(value);
		// Clear error when user starts typing
		if (error) {
			setError(null);
		}
	};

	return (
		<Dialog open={isOpen} onOpenChange={handleClose}>
			<DialogContent className="sm:max-w-[425px]">
				<DialogHeader>
					<DialogTitle>Nowa lista zakupów</DialogTitle>
					<DialogDescription>
						Utwórz nową listę zakupów. Możesz dodać produkty po jej utworzeniu.
					</DialogDescription>
				</DialogHeader>

				<form onSubmit={handleSubmit}>
					<div className="grid gap-4 py-4">
						<div className="grid gap-2">
							<Label htmlFor={listNameId}>Nazwa listy</Label>
							<Input
								id={listNameId}
								type="text"
								placeholder="np. Zakupy tygodniowe"
								value={name}
								onChange={(e) => handleNameChange(e.target.value)}
								className={error ? "border-red-500" : ""}
								disabled={isCreating}
								autoFocus
								maxLength={100}
							/>
							{error && (
								<p className="text-sm text-red-500" role="alert">
									{error}
								</p>
							)}
							<p className="text-xs text-muted-foreground">
								{name.length}/100 znaków
							</p>
						</div>
					</div>

					<DialogFooter>
						<Button
							type="button"
							variant="outline"
							onClick={handleClose}
							disabled={isCreating}
						>
							Anuluj
						</Button>
						<Button type="submit" disabled={!isNameValid || isCreating}>
							{isCreating ? "Tworzenie..." : "Utwórz"}
						</Button>
					</DialogFooter>
				</form>
			</DialogContent>
		</Dialog>
	);
}



================================================
FILE: code/src/components/lists/ListCard.tsx
================================================
import { MoreVertical, ShoppingCart, Trash2, User } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
	Card,
	CardAction,
	CardContent,
	CardHeader,
	CardTitle,
} from "@/components/ui/card";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import type { ListViewModel } from "@/types/domain.types";

interface ListCardProps {
	list: ListViewModel;
	currentUserId: string | null;
	onClick: (listId: string) => void;
	onDeleteClick: (listId: string) => void;
}

/**
 * Card component representing a single shopping list.
 * Displays list name, owner info (if shared), item counts, and action menu.
 */
export function ListCard({ list, onClick, onDeleteClick }: ListCardProps) {
	const handleCardClick = () => {
		onClick(list.id);
	};

	const handleDeleteClick = (e: Event) => {
		e.preventDefault();
		e.stopPropagation();

		// Confirmation dialog
		if (
			window.confirm(
				`Czy na pewno chcesz usunąć listę "${list.name}"? Ta operacja jest nieodwracalna.`,
			)
		) {
			onDeleteClick(list.id);
		}
	};

	// Calculate progress percentage
	const progressPercentage =
		list.totalItems > 0
			? Math.round((list.boughtItems / list.totalItems) * 100)
			: 0;

	return (
		<Card
			className="cursor-pointer transition-shadow hover:shadow-md"
			onClick={handleCardClick}
		>
			<CardHeader>
				<CardTitle className="text-lg">{list.name}</CardTitle>
				<CardAction>
					<DropdownMenu>
						<DropdownMenuTrigger asChild>
							<Button
								variant="ghost"
								size="icon"
								className="h-8 w-8"
								onClick={(e) => e.stopPropagation()}
							>
								<MoreVertical className="h-4 w-4" />
								<span className="sr-only">Otwórz menu</span>
							</Button>
						</DropdownMenuTrigger>
						<DropdownMenuContent align="end">
							<DropdownMenuItem
								className="text-red-600 focus:text-red-600"
								onSelect={handleDeleteClick}
							>
								<Trash2 className="mr-2 h-4 w-4" />
								Usuń listę
							</DropdownMenuItem>
						</DropdownMenuContent>
					</DropdownMenu>
				</CardAction>
			</CardHeader>

			<CardContent className="space-y-3">
				{/* Owner info (if shared) */}
				{list.isShared && (
					<div className="flex items-center text-sm text-muted-foreground">
						<User className="mr-2 h-4 w-4" />
						<span>Właściciel: {list.ownerName || "Współdzielona lista"}</span>
					</div>
				)}

				{/* Item counts */}
				<div className="space-y-2">
					<div className="flex items-center justify-between text-sm">
						<div className="flex items-center">
							<ShoppingCart className="mr-2 h-4 w-4 text-muted-foreground" />
							<span>
								{list.boughtItems} / {list.totalItems} produktów
							</span>
						</div>
						<span className="text-muted-foreground">{progressPercentage}%</span>
					</div>

					{/* Progress bar */}
					{list.totalItems > 0 && (
						<div className="h-2 w-full overflow-hidden rounded-full bg-secondary">
							<div
								className="h-full bg-primary transition-all duration-300"
								style={{ width: `${progressPercentage}%` }}
							/>
						</div>
					)}
				</div>

				{/* Empty state message */}
				{list.totalItems === 0 && (
					<p className="text-sm text-muted-foreground">
						Lista jest pusta. Kliknij, aby dodać produkty.
					</p>
				)}
			</CardContent>
		</Card>
	);
}



================================================
FILE: code/src/components/lists/ListsGrid.tsx
================================================
import { Plus, ShoppingBasket } from "lucide-react";
import { Button } from "@/components/ui/button";
import type { ListViewModel } from "@/types/domain.types";
import { ListCard } from "./ListCard";

interface ListsGridProps {
	lists: ListViewModel[];
	currentUserId: string | null;
	onListClick: (listId: string) => void;
	onDeleteClick: (listId: string) => void;
	onCreateClick?: () => void;
}

/**
 * Responsive grid container for displaying list cards.
 * Shows empty state when no lists are available.
 */
export function ListsGrid({
	lists,
	currentUserId,
	onListClick,
	onDeleteClick,
	onCreateClick,
}: ListsGridProps) {
	// Empty state: komunikat + przycisk "Nowa lista" (impl-plan-03, ui-plan §2.2)
	if (lists.length === 0) {
		return (
			<div className="flex flex-col items-center justify-center py-12 text-center">
				<div className="mb-4 rounded-full bg-secondary p-6">
					<ShoppingBasket className="h-12 w-12 text-muted-foreground" />
				</div>
				<h2 className="mb-2 text-xl font-semibold">
					Nie masz jeszcze żadnych list
				</h2>
				<p className="mb-6 max-w-md text-muted-foreground">
					Utwórz pierwszą listę zakupów i zacznij organizować swoje zakupy.
				</p>
				{onCreateClick && (
					<Button onClick={onCreateClick} size="default">
						<Plus className="mr-2 h-4 w-4" />
						Nowa lista
					</Button>
				)}
			</div>
		);
	}

	// Jedna kolumna – karty na pełną szerokość, bez efektu „ściśniętych kolumn” (max-w-md)
	return (
		<div className="grid grid-cols-1 gap-4">
			{lists.map((list) => (
				<ListCard
					key={list.id}
					list={list}
					currentUserId={currentUserId}
					onClick={onListClick}
					onDeleteClick={onDeleteClick}
				/>
			))}
		</div>
	);
}



================================================
FILE: code/src/components/lists/ListsHeader.tsx
================================================
import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ListsHeaderProps {
	onCreateClick: () => void;
}

/**
 * Header section for the Lists View.
 * Tytuł "Listy" pochodzi z głównego Header (MainLayout).
 * Przycisk "Nowa lista" w nagłówku – zgodnie z ui-plan §2.2.
 */
export function ListsHeader({ onCreateClick }: ListsHeaderProps) {
	return (
		<div className="flex items-center justify-end pt-4">
			<Button onClick={onCreateClick} size="default">
				<Plus className="mr-2 h-4 w-4" />
				Nowa lista
			</Button>
		</div>
	);
}



================================================
FILE: code/src/components/set-details/SetDetailsHeader.tsx
================================================
import { Link } from "@tanstack/react-router";
import { ArrowLeft, MoreVertical, Pencil, Trash2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuLabel,
	DropdownMenuSeparator,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import type { ShoppingSet } from "@/types/domain.types";

interface SetDetailsHeaderProps {
	set: ShoppingSet;
	onRename?: () => void;
	onDeleteSet?: () => void;
}

export function SetDetailsHeader({
	set,
	onRename,
	onDeleteSet,
}: SetDetailsHeaderProps) {
	return (
		<div className="flex items-center justify-between p-4 border-b bg-background sticky top-0 z-10">
			<div className="flex items-center gap-3 min-w-0 flex-1">
				<Link
					to="/sets"
					className="p-2 -ml-2 hover:bg-accent rounded-full shrink-0"
					aria-label="Wróć do zestawów"
				>
					<ArrowLeft className="h-5 w-5" />
				</Link>
				<div className="min-w-0 flex-1">
					<p className="text-xs text-muted-foreground uppercase tracking-wide">
						TRYB SZABLONU
					</p>
					<h1 className="font-semibold text-lg leading-tight truncate">
						{set.name}
					</h1>
				</div>
			</div>

			<DropdownMenu>
				<DropdownMenuTrigger asChild>
					<Button variant="ghost" size="icon">
						<MoreVertical className="h-5 w-5" />
					</Button>
				</DropdownMenuTrigger>
				<DropdownMenuContent align="end">
					<DropdownMenuLabel>Opcje zestawu</DropdownMenuLabel>
					<DropdownMenuSeparator />
					{onRename && (
						<DropdownMenuItem onClick={onRename}>
							<Pencil className="mr-2 h-4 w-4" />
							Zmień nazwę
						</DropdownMenuItem>
					)}
					{onDeleteSet && (
						<DropdownMenuItem
							onClick={onDeleteSet}
							className="text-destructive focus:text-destructive"
						>
							<Trash2 className="mr-2 h-4 w-4" />
							Usuń zestaw
						</DropdownMenuItem>
					)}
				</DropdownMenuContent>
			</DropdownMenu>
		</div>
	);
}



================================================
FILE: code/src/components/set-details/SetItemRow.tsx
================================================
import { MoreVertical, Pencil, Trash2 } from "lucide-react";
import { useState } from "react";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
import type { SetItem } from "@/types/domain.types";

interface SetItemRowProps {
	item: SetItem;
	onUpdate: (
		itemId: string,
		data: { name?: string; quantity?: string | null; note?: string | null },
	) => void;
	onDelete: (itemId: string) => void;
	isPending?: boolean;
}

export function SetItemRow({
	item,
	onUpdate,
	onDelete,
	isPending = false,
}: SetItemRowProps) {
	const [editOpen, setEditOpen] = useState(false);
	const [editName, setEditName] = useState(item.name);
	const [editQuantity, setEditQuantity] = useState(item.quantity ?? "");
	const [editNote, setEditNote] = useState(item.note ?? "");

	const openEdit = () => {
		setEditName(item.name);
		setEditQuantity(item.quantity ?? "");
		setEditNote(item.note ?? "");
		setEditOpen(true);
	};

	const submitEdit = () => {
		const nameTrimmed = editName.trim();
		if (!nameTrimmed) return;
		onUpdate(item.id, {
			name: nameTrimmed,
			quantity: editQuantity.trim() || null,
			note: editNote.trim() || null,
		});
		setEditOpen(false);
	};

	return (
		<>
			<div
				className={cn(
					"flex items-center gap-3 p-3 bg-card border rounded-lg mb-2 transition-opacity",
					isPending && "opacity-70",
				)}
			>
				<div className="flex-1 min-w-0">
					<div className="font-medium truncate">{item.name}</div>
					{(item.quantity || item.note) && (
						<div className="text-sm text-muted-foreground truncate">
							{[item.quantity, item.note].filter(Boolean).join(" · ")}
						</div>
					)}
				</div>

				<DropdownMenu>
					<DropdownMenuTrigger asChild>
						<button
							type="button"
							className="p-2 rounded-md hover:bg-muted text-muted-foreground hover:text-foreground transition-colors"
							aria-label="Otwórz menu pozycji"
						>
							<MoreVertical className="h-4 w-4" />
						</button>
					</DropdownMenuTrigger>
					<DropdownMenuContent align="end">
						<DropdownMenuItem onSelect={openEdit}>
							<Pencil className="mr-2 h-4 w-4" />
							Edycja
						</DropdownMenuItem>
						<DropdownMenuItem
							className="text-destructive focus:text-destructive"
							onSelect={() => onDelete(item.id)}
						>
							<Trash2 className="mr-2 h-4 w-4" />
							Usuń
						</DropdownMenuItem>
					</DropdownMenuContent>
				</DropdownMenu>
			</div>

			<Dialog open={editOpen} onOpenChange={setEditOpen}>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Edytuj pozycję</DialogTitle>
						<DialogDescription>
							Zmień nazwę, ilość lub notatkę.
						</DialogDescription>
					</DialogHeader>
					<div className="grid gap-4 py-4">
						<div className="grid gap-2">
							<Label htmlFor="edit-name">Nazwa</Label>
							<Input
								id="edit-name"
								value={editName}
								onChange={(e) => setEditName(e.target.value)}
								placeholder="np. Mleko"
								maxLength={100}
							/>
						</div>
						<div className="grid gap-2">
							<Label htmlFor="edit-quantity">Ilość (opcjonalnie)</Label>
							<Input
								id="edit-quantity"
								value={editQuantity}
								onChange={(e) => setEditQuantity(e.target.value)}
								placeholder="np. 2 szt"
								maxLength={50}
							/>
						</div>
						<div className="grid gap-2">
							<Label htmlFor="edit-note">Notatka (opcjonalnie)</Label>
							<Input
								id="edit-note"
								value={editNote}
								onChange={(e) => setEditNote(e.target.value)}
								placeholder="np. bez laktozy"
								maxLength={100}
							/>
						</div>
					</div>
					<DialogFooter>
						<Button variant="outline" onClick={() => setEditOpen(false)}>
							Anuluj
						</Button>
						<Button onClick={submitEdit} disabled={!editName.trim()}>
							Zapisz
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>
		</>
	);
}



================================================
FILE: code/src/components/set-details/SetItemsList.tsx
================================================
import type { SetItem } from "@/types/domain.types";
import { SetItemRow } from "./SetItemRow";

interface SetItemsListProps {
	items: SetItem[];
	pendingIds: Set<string>;
	onUpdate: (
		itemId: string,
		data: { name?: string; quantity?: string | null; note?: string | null },
	) => void;
	onDelete: (itemId: string) => void;
}

export function SetItemsList({
	items,
	pendingIds,
	onUpdate,
	onDelete,
}: SetItemsListProps) {
	return (
		<div className="pb-4">
			{items.map((item) => (
				<SetItemRow
					key={item.id}
					item={item}
					onUpdate={onUpdate}
					onDelete={onDelete}
					isPending={pendingIds.has(item.id)}
				/>
			))}
		</div>
	);
}



================================================
FILE: code/src/components/sets/AddSetToListDialog.tsx
================================================
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import { SetConflictResolutionDialog } from "@/components/list-details/SetConflictResolutionDialog";
import { listQueryKeys } from "@/hooks/useListsView";
import { listItemsService } from "@/services/items.service";
import { listsService } from "@/services/lists.service";
import { setsService } from "@/services/sets.service";
import type {
	CreateListItemDTO,
	ListItem,
	SetConflictItem,
	SetResolutionResult,
} from "@/types/domain.types";

interface AddSetToListDialogProps {
	open: boolean;
	onOpenChange: (open: boolean) => void;
	setId: string | null;
	setName: string;
	onSuccess?: () => void;
}

/**
 * Modal: wybór listy docelowej; po wyborze – dodanie pozycji zestawu do listy
 * z obsługą konfliktów nazw (SetConflictResolutionDialog).
 */
export function AddSetToListDialog({
	open,
	onOpenChange,
	setId,
	setName,
	onSuccess,
}: AddSetToListDialogProps) {
	const queryClient = useQueryClient();
	const [isAdding, setIsAdding] = useState(false);
	const [conflictDialogOpen, setConflictDialogOpen] = useState(false);
	const [conflicts, setConflicts] = useState<SetConflictItem[]>([]);
	const [nonConflictingItems, setNonConflictingItems] = useState<
		CreateListItemDTO[]
	>([]);
	const [targetListIdForConflict, setTargetListIdForConflict] =
		useState<string | null>(null);

	// Listy użytkownika (gdy dialog otwarty)
	const { data: lists = [] } = useQuery({
		queryKey: listQueryKeys.all,
		queryFn: () => listsService.getAllLists(),
		enabled: open,
	});

	const handleSelectList = async (listId: string) => {
		if (!setId) return;
		setIsAdding(true);
		try {
			const [setItems, listItems] = await Promise.all([
				setsService.getSetItems(setId),
				listItemsService.getItemsByListId(listId),
			]);

			const activeOnList = listItems.filter((i: ListItem) => !i.is_bought);
			const nameToExisting = new Map(
				activeOnList.map((i) => [i.name.toLowerCase(), i]),
			);

			const conflictsOut: SetConflictItem[] = [];
			const nonConflictingOut: CreateListItemDTO[] = [];

			for (let i = 0; i < setItems.length; i++) {
				const setItem = setItems[i];
				const dto: CreateListItemDTO = {
					list_id: listId,
					name: setItem.name,
					quantity: setItem.quantity ?? null,
					note: setItem.note ?? null,
					is_bought: false,
					sort_order: setItem.sort_order ?? i,
				};
				const existing = nameToExisting.get(setItem.name.toLowerCase());
				if (existing) {
					const suggestedQuantity = [existing.quantity, setItem.quantity]
						.filter(Boolean)
						.join("+") || "—";
					conflictsOut.push({
						existingItem: existing,
						newItemCandidate: dto,
						suggestedQuantity,
					});
				} else {
					nonConflictingOut.push(dto);
				}
			}

			if (conflictsOut.length === 0) {
				if (nonConflictingOut.length > 0) {
					await listItemsService.bulkCreateItems(nonConflictingOut);
				}
				queryClient.invalidateQueries({ queryKey: ["list-items", listId] });
				queryClient.invalidateQueries({ queryKey: listQueryKeys.all });
				onOpenChange(false);
				onSuccess?.();
			} else {
				setConflicts(conflictsOut);
				setNonConflictingItems(nonConflictingOut);
				setTargetListIdForConflict(listId);
				setConflictDialogOpen(true);
			}
		} catch (err) {
			console.error("Add set to list failed:", err);
		} finally {
			setIsAdding(false);
		}
	};

	const handleConflictResolve = async (resolution: SetResolutionResult) => {
		if (!targetListIdForConflict) return;
		try {
			if (resolution.itemsToCreate.length > 0) {
				await listItemsService.bulkCreateItems(resolution.itemsToCreate);
			}
			for (const u of resolution.itemsToUpdate) {
				await listItemsService.updateItem({
					id: u.itemId,
					quantity: u.newQuantity,
				});
			}
			queryClient.invalidateQueries({
				queryKey: ["list-items", targetListIdForConflict],
			});
			queryClient.invalidateQueries({ queryKey: listQueryKeys.all });
			setConflictDialogOpen(false);
			setTargetListIdForConflict(null);
			onOpenChange(false);
			onSuccess?.();
		} catch (err) {
			console.error("Conflict resolve failed:", err);
		}
	};

	const handleConflictCancel = () => {
		setConflictDialogOpen(false);
		setTargetListIdForConflict(null);
		setConflicts([]);
		setNonConflictingItems([]);
	};

	const handleClose = (open: boolean) => {
		if (!open) {
			setConflictDialogOpen(false);
			setTargetListIdForConflict(null);
		}
		onOpenChange(open);
	};

	return (
		<>
			<Dialog open={open} onOpenChange={handleClose}>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Dodaj zestaw do listy</DialogTitle>
						<DialogDescription>
							Wybierz listę, na którą chcesz dodać zestaw „{setName}”.
						</DialogDescription>
					</DialogHeader>
					<div className="flex flex-col gap-2 py-4 max-h-[60vh] overflow-y-auto">
						{lists.length === 0 ? (
							<p className="text-sm text-muted-foreground">
								Brak list. Utwórz najpierw listę w zakładce Listy.
							</p>
						) : (
							lists.map((list) => (
								<Button
									key={list.id}
									variant="outline"
									className="justify-start"
									onClick={() => handleSelectList(list.id)}
									disabled={isAdding}
								>
									{list.name}
								</Button>
							))
						)}
					</div>
				</DialogContent>
			</Dialog>

			<SetConflictResolutionDialog
				isOpen={conflictDialogOpen}
				conflicts={conflicts}
				nonConflictingItems={nonConflictingItems}
				onResolve={handleConflictResolve}
				onCancel={handleConflictCancel}
			/>
		</>
	);
}



================================================
FILE: code/src/components/sets/CreateSetDialog.tsx
================================================
import { type FormEvent, useId, useState } from "react";
import { useNavigate } from "@tanstack/react-router";
import { Button } from "@/components/ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { CreateSetDTO, ShoppingSet } from "@/types/domain.types";

interface CreateSetDialogProps {
	isOpen: boolean;
	onClose: () => void;
	onCreateSet: (data: CreateSetDTO) => Promise<ShoppingSet>;
	isCreating: boolean;
}

/**
 * Dialog for creating a new empty set (template).
 * On success: invalidate sets and optionally navigate to /sets/:setId.
 */
export function CreateSetDialog({
	isOpen,
	onClose,
	onCreateSet,
	isCreating,
}: CreateSetDialogProps) {
	const navigate = useNavigate();
	const [name, setName] = useState("");
	const [error, setError] = useState<string | null>(null);
	const setNameId = useId();

	const isNameValid = name.trim().length > 0 && name.trim().length <= 100;

	const handleSubmit = async (e: FormEvent) => {
		e.preventDefault();
		const trimmedName = name.trim();
		if (!trimmedName) {
			setError("Nazwa zestawu jest wymagana");
			return;
		}
		if (trimmedName.length > 100) {
			setError("Nazwa zestawu może mieć maksymalnie 100 znaków");
			return;
		}
		setError(null);
		try {
			const newSet = await onCreateSet({ name: trimmedName });
			setName("");
			setError(null);
			onClose();
			navigate({ to: "/sets/$setId", params: { setId: newSet.id } });
		} catch (err) {
			setError(
				err instanceof Error
					? err.message
					: "Nie udało się utworzyć zestawu. Spróbuj ponownie.",
			);
		}
	};

	const handleClose = () => {
		setName("");
		setError(null);
		onClose();
	};

	return (
		<Dialog open={isOpen} onOpenChange={(open) => !open && handleClose()}>
			<DialogContent className="sm:max-w-[425px]">
				<DialogHeader>
					<DialogTitle>Nowy zestaw</DialogTitle>
					<DialogDescription>
						Utwórz pusty zestaw (szablon). Dodasz do niego produkty w widoku
						szczegółów.
					</DialogDescription>
				</DialogHeader>
				<form onSubmit={handleSubmit}>
					<div className="grid gap-4 py-4">
						<div className="grid gap-2">
							<Label htmlFor={setNameId}>Nazwa zestawu</Label>
							<Input
								id={setNameId}
								type="text"
								placeholder="np. Śniadanie"
								value={name}
								onChange={(e) => {
									setName(e.target.value);
									if (error) setError(null);
								}}
								className={error ? "border-destructive" : ""}
								disabled={isCreating}
								autoFocus
								maxLength={100}
							/>
							{error && (
								<p className="text-sm text-destructive" role="alert">
									{error}
								</p>
							)}
							<p className="text-xs text-muted-foreground">
								{name.length}/100 znaków
							</p>
						</div>
					</div>
					<DialogFooter>
						<Button
							type="button"
							variant="outline"
							onClick={handleClose}
							disabled={isCreating}
						>
							Anuluj
						</Button>
						<Button type="submit" disabled={!isNameValid || isCreating}>
							{isCreating ? "Tworzenie..." : "Utwórz"}
						</Button>
					</DialogFooter>
				</form>
			</DialogContent>
		</Dialog>
	);
}



================================================
FILE: code/src/components/sets/SetCard.tsx
================================================
import { ListPlus } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
	Card,
	CardContent,
	CardFooter,
	CardHeader,
	CardTitle,
} from "@/components/ui/card";
import type { ShoppingSet } from "@/types/domain.types";

interface SetCardProps {
	set: ShoppingSet;
	/** Opcjonalna liczba produktów w zestawie (jeśli dostępna) */
	itemCount?: number;
	onAddToList: (setId: string) => void;
	/** Klik w nazwę zestawu – nawigacja do szczegółów (opcjonalnie) */
	onSetClick?: (setId: string) => void;
}

/**
 * Card component for a single set (template).
 * Displays set name, optional item count, and "Dodaj do listy" button.
 */
export function SetCard({
	set,
	itemCount,
	onAddToList,
	onSetClick,
}: SetCardProps) {
	const handleAddClick = (e: React.MouseEvent) => {
		e.stopPropagation();
		onAddToList(set.id);
	};

	const handleCardClick = () => {
		if (onSetClick) onSetClick(set.id);
	};

	return (
		<Card
			className={onSetClick ? "cursor-pointer transition-shadow hover:shadow-md" : ""}
			onClick={onSetClick ? handleCardClick : undefined}
		>
			<CardHeader>
				<CardTitle className="text-lg">{set.name}</CardTitle>
			</CardHeader>
			<CardContent>
				{itemCount !== undefined && (
					<p className="text-sm text-muted-foreground">
						{itemCount} {itemCount === 1 ? "produkt" : "produktów"}
					</p>
				)}
			</CardContent>
			<CardFooter>
				<Button
					variant="default"
					size="sm"
					className="w-full"
					onClick={handleAddClick}
				>
					<ListPlus className="mr-2 h-4 w-4" />
					Dodaj do listy
				</Button>
			</CardFooter>
		</Card>
	);
}



================================================
FILE: code/src/components/sets/SetsGrid.tsx
================================================
import { Layers } from "lucide-react";
import { Button } from "@/components/ui/button";
import { SetCard } from "./SetCard";
import type { ShoppingSet } from "@/types/domain.types";

interface SetWithCount extends ShoppingSet {
	itemCount?: number;
}

interface SetsGridProps {
	sets: SetWithCount[];
	onAddToList: (setId: string) => void;
	onCreateSet?: () => void;
	onSetClick?: (setId: string) => void;
}

/**
 * Grid of set cards. Empty state with optional "Utwórz pierwszy zestaw" button.
 */
export function SetsGrid({
	sets,
	onAddToList,
	onCreateSet,
	onSetClick,
}: SetsGridProps) {
	if (sets.length === 0) {
		return (
			<div className="flex flex-col items-center justify-center py-12 text-center">
				<div className="mb-4 rounded-full bg-secondary p-6">
					<Layers className="h-12 w-12 text-muted-foreground" />
				</div>
				<h2 className="mb-2 text-xl font-semibold">
					Nie masz jeszcze żadnych zestawów
				</h2>
				<p className="mb-6 max-w-md text-muted-foreground">
					Utwórz zestaw (szablon) produktów, aby szybko dodawać je do list
					zakupów.
				</p>
				{onCreateSet && (
					<Button onClick={onCreateSet} size="default">
						Utwórz pierwszy zestaw
					</Button>
				)}
			</div>
		);
	}

	return (
		<div className="grid grid-cols-1 gap-4">
			{sets.map((set) => (
				<SetCard
					key={set.id}
					set={set}
					itemCount={set.itemCount}
					onAddToList={onAddToList}
					onSetClick={onSetClick}
				/>
			))}
		</div>
	);
}



================================================
FILE: code/src/components/sets/SetsHeader.tsx
================================================
import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";

interface SetsHeaderProps {
	onCreateClick?: () => void;
}

/**
 * Header section for the Sets Dashboard.
 * Tytuł "Zestawy" pochodzi z głównego Header (MainLayout).
 * Opcjonalny przycisk "Nowy zestaw" – zgodnie z ui-plan §2.4, impl-plan-05.
 */
export function SetsHeader({ onCreateClick }: SetsHeaderProps) {
	return (
		<div className="flex items-center justify-end pt-4">
			{onCreateClick && (
				<Button onClick={onCreateClick} size="default">
					<Plus className="mr-2 h-4 w-4" />
					Nowy zestaw
				</Button>
			)}
		</div>
	);
}



================================================
FILE: code/src/components/ui/button.tsx
================================================
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
	{
		variants: {
			variant: {
				default: "bg-primary text-primary-foreground hover:bg-primary/90",
				destructive:
					"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
				outline:
					"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
				secondary:
					"bg-secondary text-secondary-foreground hover:bg-secondary/80",
				ghost:
					"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-9 px-4 py-2 has-[>svg]:px-3",
				xs: "h-6 gap-1 rounded-md px-2 text-xs has-[>svg]:px-1.5 [&_svg:not([class*='size-'])]:size-3",
				sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
				lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
				icon: "size-9",
				"icon-xs": "size-6 rounded-md [&_svg:not([class*='size-'])]:size-3",
				"icon-sm": "size-8",
				"icon-lg": "size-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

function Button({
	className,
	variant = "default",
	size = "default",
	asChild = false,
	...props
}: React.ComponentProps<"button"> &
	VariantProps<typeof buttonVariants> & {
		asChild?: boolean;
	}) {
	const Comp = asChild ? Slot : "button";

	return (
		<Comp
			data-slot="button"
			data-variant={variant}
			data-size={size}
			className={cn(buttonVariants({ variant, size, className }))}
			{...props}
		/>
	);
}

export { Button, buttonVariants };



================================================
FILE: code/src/components/ui/card.tsx
================================================
import type * as React from "react";

import { cn } from "@/lib/utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card"
			className={cn(
				"bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
				className,
			)}
			{...props}
		/>
	);
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-header"
			className={cn(
				"@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
				className,
			)}
			{...props}
		/>
	);
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-title"
			className={cn("leading-none font-semibold", className)}
			{...props}
		/>
	);
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-description"
			className={cn("text-muted-foreground text-sm", className)}
			{...props}
		/>
	);
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-action"
			className={cn(
				"col-start-2 row-span-2 row-start-1 self-start justify-self-end",
				className,
			)}
			{...props}
		/>
	);
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-content"
			className={cn("px-6", className)}
			{...props}
		/>
	);
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
	return (
		<div
			data-slot="card-footer"
			className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
			{...props}
		/>
	);
}

export {
	Card,
	CardHeader,
	CardFooter,
	CardTitle,
	CardAction,
	CardDescription,
	CardContent,
};



================================================
FILE: code/src/components/ui/checkbox.tsx
================================================
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
	React.ElementRef<typeof CheckboxPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
	<CheckboxPrimitive.Root
		ref={ref}
		className={cn(
			"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
			className,
		)}
		{...props}
	>
		<CheckboxPrimitive.Indicator
			className={cn("flex items-center justify-center text-current")}
		>
			<Check className="h-4 w-4" />
		</CheckboxPrimitive.Indicator>
	</CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };



================================================
FILE: code/src/components/ui/dialog.tsx
================================================
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Overlay>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Overlay
		ref={ref}
		className={cn(
			"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
			className,
		)}
		{...props}
	/>
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
	<DialogPortal>
		<DialogOverlay />
		<DialogPrimitive.Content
			ref={ref}
			className={cn(
				"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
				className,
			)}
			{...props}
		>
			{children}
			<DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
				<X className="h-4 w-4" />
				<span className="sr-only">Close</span>
			</DialogPrimitive.Close>
		</DialogPrimitive.Content>
	</DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) => (
	<div
		className={cn(
			"flex flex-col space-y-1.5 text-center sm:text-left",
			className,
		)}
		{...props}
	/>
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) => (
	<div
		className={cn(
			"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
			className,
		)}
		{...props}
	/>
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Title>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Title
		ref={ref}
		className={cn(
			"text-lg font-semibold leading-none tracking-tight",
			className,
		)}
		{...props}
	/>
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Description>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Description
		ref={ref}
		className={cn("text-sm text-muted-foreground", className)}
		{...props}
	/>
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
	Dialog,
	DialogPortal,
	DialogOverlay,
	DialogClose,
	DialogTrigger,
	DialogContent,
	DialogHeader,
	DialogFooter,
	DialogTitle,
	DialogDescription,
};



================================================
FILE: code/src/components/ui/dropdown-menu.tsx
================================================
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
		inset?: boolean;
	}
>(({ className, inset, children, ...props }, ref) => (
	<DropdownMenuPrimitive.SubTrigger
		ref={ref}
		className={cn(
			"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
			inset && "pl-8",
			className,
		)}
		{...props}
	>
		{children}
		<ChevronRight className="ml-auto h-4 w-4" />
	</DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
	DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
	<DropdownMenuPrimitive.SubContent
		ref={ref}
		className={cn(
			"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
			className,
		)}
		{...props}
	/>
));
DropdownMenuSubContent.displayName =
	DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
	<DropdownMenuPrimitive.Portal>
		<DropdownMenuPrimitive.Content
			ref={ref}
			sideOffset={sideOffset}
			className={cn(
				"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				className,
			)}
			{...props}
		/>
	</DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
		inset?: boolean;
	}
>(({ className, inset, ...props }, ref) => (
	<DropdownMenuPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			inset && "pl-8",
			className,
		)}
		{...props}
	/>
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
	<DropdownMenuPrimitive.CheckboxItem
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		checked={checked}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<DropdownMenuPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</DropdownMenuPrimitive.ItemIndicator>
		</span>
		{children}
	</DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
	DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
	<DropdownMenuPrimitive.RadioItem
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<DropdownMenuPrimitive.ItemIndicator>
				<Circle className="h-2 w-2 fill-current" />
			</DropdownMenuPrimitive.ItemIndicator>
		</span>
		{children}
	</DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
		inset?: boolean;
	}
>(({ className, inset, ...props }, ref) => (
	<DropdownMenuPrimitive.Label
		ref={ref}
		className={cn(
			"px-2 py-1.5 text-sm font-semibold",
			inset && "pl-8",
			className,
		)}
		{...props}
	/>
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<DropdownMenuPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
	className,
	...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
	return (
		<span
			className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
			{...props}
		/>
	);
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
	DropdownMenu,
	DropdownMenuTrigger,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuCheckboxItem,
	DropdownMenuRadioItem,
	DropdownMenuLabel,
	DropdownMenuSeparator,
	DropdownMenuShortcut,
	DropdownMenuGroup,
	DropdownMenuPortal,
	DropdownMenuSub,
	DropdownMenuSubContent,
	DropdownMenuSubTrigger,
	DropdownMenuRadioGroup,
};



================================================
FILE: code/src/components/ui/input.tsx
================================================
import type * as React from "react";

import { cn } from "@/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
	return (
		<input
			type={type}
			data-slot="input"
			className={cn(
				"file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
				"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
				"aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
				className,
			)}
			{...props}
		/>
	);
}

export { Input };



================================================
FILE: code/src/components/ui/label.tsx
================================================
import * as LabelPrimitive from "@radix-ui/react-label";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Label({
	className,
	...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
	return (
		<LabelPrimitive.Root
			data-slot="label"
			className={cn(
				"flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
				className,
			)}
			{...props}
		/>
	);
}

export { Label };



================================================
FILE: code/src/components/ui/separator.tsx
================================================
import * as SeparatorPrimitive from "@radix-ui/react-separator";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Separator({
	className,
	orientation = "horizontal",
	decorative = true,
	...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
	return (
		<SeparatorPrimitive.Root
			data-slot="separator"
			decorative={decorative}
			orientation={orientation}
			className={cn(
				"bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
				className,
			)}
			{...props}
		/>
	);
}

export { Separator };



================================================
FILE: code/src/components/ui/tabs.tsx
================================================
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Tabs({
	className,
	orientation = "horizontal",
	...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
	return (
		<TabsPrimitive.Root
			data-slot="tabs"
			data-orientation={orientation}
			orientation={orientation}
			className={cn(
				"group/tabs flex gap-2 data-[orientation=horizontal]:flex-col",
				className,
			)}
			{...props}
		/>
	);
}

const tabsListVariants = cva(
	"rounded-lg p-[3px] group-data-[orientation=horizontal]/tabs:h-9 data-[variant=line]:rounded-none group/tabs-list text-muted-foreground inline-flex w-fit items-center justify-center group-data-[orientation=vertical]/tabs:h-fit group-data-[orientation=vertical]/tabs:flex-col",
	{
		variants: {
			variant: {
				default: "bg-muted",
				line: "gap-1 bg-transparent",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

function TabsList({
	className,
	variant = "default",
	...props
}: React.ComponentProps<typeof TabsPrimitive.List> &
	VariantProps<typeof tabsListVariants>) {
	return (
		<TabsPrimitive.List
			data-slot="tabs-list"
			data-variant={variant}
			className={cn(tabsListVariants({ variant }), className)}
			{...props}
		/>
	);
}

function TabsTrigger({
	className,
	...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
	return (
		<TabsPrimitive.Trigger
			data-slot="tabs-trigger"
			className={cn(
				"focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring text-foreground/60 hover:text-foreground dark:text-muted-foreground dark:hover:text-foreground relative inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-all group-data-[orientation=vertical]/tabs:w-full group-data-[orientation=vertical]/tabs:justify-start focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 group-data-[variant=default]/tabs-list:data-[state=active]:shadow-sm group-data-[variant=line]/tabs-list:data-[state=active]:shadow-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				"group-data-[variant=line]/tabs-list:bg-transparent group-data-[variant=line]/tabs-list:data-[state=active]:bg-transparent dark:group-data-[variant=line]/tabs-list:data-[state=active]:border-transparent dark:group-data-[variant=line]/tabs-list:data-[state=active]:bg-transparent",
				"data-[state=active]:bg-background dark:data-[state=active]:text-foreground dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 data-[state=active]:text-foreground",
				"after:bg-foreground after:absolute after:opacity-0 after:transition-opacity group-data-[orientation=horizontal]/tabs:after:inset-x-0 group-data-[orientation=horizontal]/tabs:after:bottom-[-5px] group-data-[orientation=horizontal]/tabs:after:h-0.5 group-data-[orientation=vertical]/tabs:after:inset-y-0 group-data-[orientation=vertical]/tabs:after:-right-1 group-data-[orientation=vertical]/tabs:after:w-0.5 group-data-[variant=line]/tabs-list:data-[state=active]:after:opacity-100",
				className,
			)}
			{...props}
		/>
	);
}

function TabsContent({
	className,
	...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
	return (
		<TabsPrimitive.Content
			data-slot="tabs-content"
			className={cn("flex-1 outline-none", className)}
			{...props}
		/>
	);
}

export { Tabs, TabsList, TabsTrigger, TabsContent, tabsListVariants };



================================================
FILE: code/src/db/database.types.ts
================================================
export type Json =
	| string
	| number
	| boolean
	| null
	| { [key: string]: Json | undefined }
	| Json[];

export type Database = {
	// Allows to automatically instantiate createClient with right options
	// instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
	__InternalSupabase: {
		PostgrestVersion: "14.1";
	};
	public: {
		Tables: {
			list_items: {
				Row: {
					created_at: string | null;
					id: string;
					is_bought: boolean | null;
					list_id: string;
					name: string;
					note: string | null;
					quantity: string | null;
					sort_order: number | null;
					updated_at: string | null;
				};
				Insert: {
					created_at?: string | null;
					id?: string;
					is_bought?: boolean | null;
					list_id: string;
					name: string;
					note?: string | null;
					quantity?: string | null;
					sort_order?: number | null;
					updated_at?: string | null;
				};
				Update: {
					created_at?: string | null;
					id?: string;
					is_bought?: boolean | null;
					list_id?: string;
					name?: string;
					note?: string | null;
					quantity?: string | null;
					sort_order?: number | null;
					updated_at?: string | null;
				};
				Relationships: [
					{
						foreignKeyName: "list_items_list_id_fkey";
						columns: ["list_id"];
						isOneToOne: false;
						referencedRelation: "lists";
						referencedColumns: ["id"];
					},
				];
			};
			list_members: {
				Row: {
					created_at: string | null;
					list_id: string;
					user_id: string;
				};
				Insert: {
					created_at?: string | null;
					list_id: string;
					user_id: string;
				};
				Update: {
					created_at?: string | null;
					list_id?: string;
					user_id?: string;
				};
				Relationships: [
					{
						foreignKeyName: "list_members_list_id_fkey";
						columns: ["list_id"];
						isOneToOne: false;
						referencedRelation: "lists";
						referencedColumns: ["id"];
					},
					{
						foreignKeyName: "list_members_user_id_fkey";
						columns: ["user_id"];
						isOneToOne: false;
						referencedRelation: "profiles";
						referencedColumns: ["id"];
					},
				];
			};
			lists: {
				Row: {
					created_at: string | null;
					created_by: string;
					id: string;
					name: string;
					updated_at: string | null;
				};
				Insert: {
					created_at?: string | null;
					created_by: string;
					id?: string;
					name: string;
					updated_at?: string | null;
				};
				Update: {
					created_at?: string | null;
					created_by?: string;
					id?: string;
					name?: string;
					updated_at?: string | null;
				};
				Relationships: [];
			};
			profiles: {
				Row: {
					email: string | null;
					full_name: string | null;
					id: string;
					updated_at: string | null;
				};
				Insert: {
					email?: string | null;
					full_name?: string | null;
					id: string;
					updated_at?: string | null;
				};
				Update: {
					email?: string | null;
					full_name?: string | null;
					id?: string;
					updated_at?: string | null;
				};
				Relationships: [];
			};
			set_items: {
				Row: {
					created_at: string | null;
					id: string;
					name: string;
					note: string | null;
					quantity: string | null;
					set_id: string;
					sort_order: number | null;
					updated_at: string | null;
				};
				Insert: {
					created_at?: string | null;
					id?: string;
					name: string;
					note?: string | null;
					quantity?: string | null;
					set_id: string;
					sort_order?: number | null;
					updated_at?: string | null;
				};
				Update: {
					created_at?: string | null;
					id?: string;
					name?: string;
					note?: string | null;
					quantity?: string | null;
					set_id?: string;
					sort_order?: number | null;
					updated_at?: string | null;
				};
				Relationships: [
					{
						foreignKeyName: "set_items_set_id_fkey";
						columns: ["set_id"];
						isOneToOne: false;
						referencedRelation: "sets";
						referencedColumns: ["id"];
					},
				];
			};
			set_members: {
				Row: {
					created_at: string | null;
					set_id: string;
					user_id: string;
				};
				Insert: {
					created_at?: string | null;
					set_id: string;
					user_id: string;
				};
				Update: {
					created_at?: string | null;
					set_id?: string;
					user_id?: string;
				};
				Relationships: [
					{
						foreignKeyName: "set_members_set_id_fkey";
						columns: ["set_id"];
						isOneToOne: false;
						referencedRelation: "sets";
						referencedColumns: ["id"];
					},
					{
						foreignKeyName: "set_members_user_id_fkey";
						columns: ["user_id"];
						isOneToOne: false;
						referencedRelation: "profiles";
						referencedColumns: ["id"];
					},
				];
			};
			sets: {
				Row: {
					created_at: string | null;
					created_by: string;
					description: string | null;
					id: string;
					name: string;
					updated_at: string | null;
				};
				Insert: {
					created_at?: string | null;
					created_by: string;
					description?: string | null;
					id?: string;
					name: string;
					updated_at?: string | null;
				};
				Update: {
					created_at?: string | null;
					created_by?: string;
					description?: string | null;
					id?: string;
					name?: string;
					updated_at?: string | null;
				};
				Relationships: [];
			};
			shopping_history: {
				Row: {
					completed_at: string | null;
					id: string;
					items_snapshot: Json;
					list_name: string;
					user_id: string;
				};
				Insert: {
					completed_at?: string | null;
					id?: string;
					items_snapshot: Json;
					list_name: string;
					user_id: string;
				};
				Update: {
					completed_at?: string | null;
					id?: string;
					items_snapshot?: Json;
					list_name?: string;
					user_id?: string;
				};
				Relationships: [
					{
						foreignKeyName: "shopping_history_user_id_fkey";
						columns: ["user_id"];
						isOneToOne: false;
						referencedRelation: "profiles";
						referencedColumns: ["id"];
					},
				];
			};
		};
		Views: {
			[_ in never]: never;
		};
		Functions: {
			archive_list_items: { Args: { p_list_id: string }; Returns: undefined };
			invite_member_to_list: {
				Args: { p_list_id: string; p_user_id: string };
				Returns: undefined;
			};
			invite_member_to_set: {
				Args: { p_set_id: string; p_user_id: string };
				Returns: undefined;
			};
		};
		Enums: {
			[_ in never]: never;
		};
		CompositeTypes: {
			[_ in never]: never;
		};
	};
};

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">;

type DefaultSchema = DatabaseWithoutInternals[Extract<
	keyof Database,
	"public"
>];

export type Tables<
	DefaultSchemaTableNameOrOptions extends
		| keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
		| { schema: keyof DatabaseWithoutInternals },
	TableName extends DefaultSchemaTableNameOrOptions extends {
		schema: keyof DatabaseWithoutInternals;
	}
		? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
				DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
		: never = never,
> = DefaultSchemaTableNameOrOptions extends {
	schema: keyof DatabaseWithoutInternals;
}
	? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
			DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
			Row: infer R;
		}
		? R
		: never
	: DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
				DefaultSchema["Views"])
		? (DefaultSchema["Tables"] &
				DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
				Row: infer R;
			}
			? R
			: never
		: never;

export type TablesInsert<
	DefaultSchemaTableNameOrOptions extends
		| keyof DefaultSchema["Tables"]
		| { schema: keyof DatabaseWithoutInternals },
	TableName extends DefaultSchemaTableNameOrOptions extends {
		schema: keyof DatabaseWithoutInternals;
	}
		? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
		: never = never,
> = DefaultSchemaTableNameOrOptions extends {
	schema: keyof DatabaseWithoutInternals;
}
	? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
			Insert: infer I;
		}
		? I
		: never
	: DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
		? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
				Insert: infer I;
			}
			? I
			: never
		: never;

export type TablesUpdate<
	DefaultSchemaTableNameOrOptions extends
		| keyof DefaultSchema["Tables"]
		| { schema: keyof DatabaseWithoutInternals },
	TableName extends DefaultSchemaTableNameOrOptions extends {
		schema: keyof DatabaseWithoutInternals;
	}
		? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
		: never = never,
> = DefaultSchemaTableNameOrOptions extends {
	schema: keyof DatabaseWithoutInternals;
}
	? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
			Update: infer U;
		}
		? U
		: never
	: DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
		? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
				Update: infer U;
			}
			? U
			: never
		: never;

export type Enums<
	DefaultSchemaEnumNameOrOptions extends
		| keyof DefaultSchema["Enums"]
		| { schema: keyof DatabaseWithoutInternals },
	EnumName extends DefaultSchemaEnumNameOrOptions extends {
		schema: keyof DatabaseWithoutInternals;
	}
		? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
		: never = never,
> = DefaultSchemaEnumNameOrOptions extends {
	schema: keyof DatabaseWithoutInternals;
}
	? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
	: DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
		? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
		: never;

export type CompositeTypes<
	PublicCompositeTypeNameOrOptions extends
		| keyof DefaultSchema["CompositeTypes"]
		| { schema: keyof DatabaseWithoutInternals },
	CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
		schema: keyof DatabaseWithoutInternals;
	}
		? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
		: never = never,
> = PublicCompositeTypeNameOrOptions extends {
	schema: keyof DatabaseWithoutInternals;
}
	? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
	: PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
		? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
		: never;

export const Constants = {
	public: {
		Enums: {},
	},
} as const;



================================================
FILE: code/src/db/supabase.client.ts
================================================
import { createClient } from "@supabase/supabase-js";
import { cfg } from "../config.ts";
import type { Database } from "./database.types.ts";

const supabaseUrl = cfg.SUPABASE_URL;
const supabaseAnonKey = cfg.SUPABASE_KEY;

export const supabaseClient = createClient<Database>(
	supabaseUrl,
	supabaseAnonKey,
);



================================================
FILE: code/src/hooks/useListDetails.ts
================================================
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import type { Database } from "@/db/database.types";
import { listQueryKeys } from "@/hooks/useListsView";
import { listItemsService } from "@/services/items.service";
import { listsService } from "@/services/lists.service";
import type {
	CreateListItemDTO,
	SingleItemConflictState,
	UpdateListItemDTO,
} from "@/types/domain.types";

type ListItem = Database["public"]["Tables"]["list_items"]["Row"];

export function useListDetails(listId: string) {
	const queryClient = useQueryClient();
	const [conflictState, setConflictState] = useState<SingleItemConflictState>({
		isOpen: false,
	});
	const [pendingIds, setPendingIds] = useState<Set<string>>(new Set());

	// Helper to check if error is a network error
	const isNetworkError = (error: unknown) => {
		// In many browsers, a failed fetch due to no network results in a TypeError
		// or an error that doesn't have a status code (like Supabase/PostgREST errors)
		const err = error as { status?: number; message?: string; name?: string };
		return (
			!err?.status &&
			(err?.message === "Failed to fetch" ||
				err?.name === "TypeError" ||
				!navigator.onLine)
		);
	};

	// Fetch List Details
	const {
		data: list,
		isLoading: isListLoading,
		error: listError,
	} = useQuery({
		queryKey: ["list", listId],
		queryFn: () => listsService.getListById(listId),
		networkMode: "offlineFirst",
	});

	// Fetch List Items
	const { data: items = [], isLoading: isItemsLoading } = useQuery({
		queryKey: ["list-items", listId],
		queryFn: () => listItemsService.getItemsByListId(listId),
		networkMode: "offlineFirst",
	});

	// Derived state
	const activeItems = items.filter((item) => !item.is_bought);
	const completedItems = items.filter((item) => item.is_bought);

	// Mutations
	const createItemMutation = useMutation({
		mutationKey: ["list-items", "create", listId],
		// Add scope to ensure mutations for this list run sequentially
		scope: { id: `list-${listId}` },
		mutationFn: ({ data }: { type: "create"; data: CreateListItemDTO }) =>
			listItemsService.createItem(data),
		networkMode: "offlineFirst",
		onMutate: async (variables) => {
			const newItem = variables.data;
			const optimisticId = crypto.randomUUID();
			await queryClient.cancelQueries({ queryKey: ["list-items", listId] });
			const previousItems = queryClient.getQueryData<ListItem[]>([
				"list-items",
				listId,
			]);

			queryClient.setQueryData<ListItem[]>(["list-items", listId], (old) => {
				const optimisticItem: ListItem = {
					id: optimisticId,
					list_id: listId,
					name: newItem.name,
					quantity: newItem.quantity ?? null,
					is_bought: newItem.is_bought ?? false,
					note: newItem.note ?? null,
					sort_order: newItem.sort_order ?? 0,
					created_at: new Date().toISOString(),
					updated_at: new Date().toISOString(),
				};
				return old ? [...old, optimisticItem] : [optimisticItem];
			});

			setPendingIds((prev) => new Set(prev).add(optimisticId));
			return { previousItems, optimisticId };
		},
		onError: (err, _variables, context) => {
			// Only rollback if it's NOT a network error
			if (context?.previousItems && !isNetworkError(err)) {
				queryClient.setQueryData(["list-items", listId], context.previousItems);
			}
		},
		onSettled: (_data, _error, _variables, context) => {
			if (context?.optimisticId) {
				setPendingIds((prev) => {
					const next = new Set(prev);
					next.delete(context.optimisticId);
					return next;
				});
			}
		},
	});

	const updateItemMutation = useMutation({
		mutationKey: ["list-items", "update", listId],
		// Add scope to ensure mutations for this list run sequentially
		scope: { id: `list-${listId}` },
		mutationFn: ({ data }: { type: "update"; data: UpdateListItemDTO }) =>
			listItemsService.updateItem(data),
		networkMode: "offlineFirst",
		onMutate: async (variables) => {
			const updatedItem = variables.data;
			await queryClient.cancelQueries({ queryKey: ["list-items", listId] });
			const previousItems = queryClient.getQueryData<ListItem[]>([
				"list-items",
				listId,
			]);

			queryClient.setQueryData<ListItem[]>(["list-items", listId], (old) => {
				return old?.map((item) =>
					item.id === updatedItem.id ? { ...item, ...updatedItem } : item,
				);
			});

			setPendingIds((prev) => new Set(prev).add(updatedItem.id));
			return { previousItems, itemId: updatedItem.id };
		},
		onError: (err, _variables, context) => {
			if (context?.previousItems && !isNetworkError(err)) {
				queryClient.setQueryData(["list-items", listId], context.previousItems);
			}
		},
		onSettled: (_data, _error, _variables, context) => {
			if (context?.itemId) {
				setPendingIds((prev) => {
					const next = new Set(prev);
					next.delete(context.itemId);
					return next;
				});
			}
		},
	});

	const deleteItemMutation = useMutation({
		mutationKey: ["list-items", "delete", listId],
		// Add scope to ensure mutations for this list run sequentially
		scope: { id: `list-${listId}` },
		mutationFn: ({ itemId }: { type: "delete"; itemId: string }) =>
			listItemsService.deleteItem(itemId),
		networkMode: "offlineFirst",
		onMutate: async (variables) => {
			const itemId = variables.itemId;
			await queryClient.cancelQueries({ queryKey: ["list-items", listId] });
			const previousItems = queryClient.getQueryData<ListItem[]>([
				"list-items",
				listId,
			]);

			queryClient.setQueryData<ListItem[]>(["list-items", listId], (old) => {
				return old?.filter((item) => item.id !== itemId);
			});

			setPendingIds((prev) => new Set(prev).add(itemId));
			return { previousItems, itemId };
		},
		onError: (err, _variables, context) => {
			if (context?.previousItems && !isNetworkError(err)) {
				queryClient.setQueryData(["list-items", listId], context.previousItems);
			}
		},
		onSettled: (_data, _error, _variables, context) => {
			if (context?.itemId) {
				setPendingIds((prev) => {
					const next = new Set(prev);
					next.delete(context.itemId);
					return next;
				});
			}
		},
	});

	const reorderItemsMutation = useMutation({
		mutationKey: ["list-items", "reorder", listId],
		scope: { id: `list-${listId}` },
		mutationFn: (orderedItems: ListItem[]) => {
			const payload = orderedItems.map((item, index) => ({
				id: item.id,
				sort_order: index,
			}));
			return listItemsService.reorderItems(payload);
		},
		networkMode: "offlineFirst",
		onMutate: async (orderedItems) => {
			await queryClient.cancelQueries({ queryKey: ["list-items", listId] });
			const previousItems = queryClient.getQueryData<ListItem[]>([
				"list-items",
				listId,
			]);
			// Reorder: active items get new order, completed stay at end with original relative order
			const completed = (previousItems ?? []).filter((i) => i.is_bought);
			const reorderedActive = orderedItems.map((item, index) => ({
				...item,
				sort_order: index,
			}));
			const completedWithOrder = completed.map((item, index) => ({
				...item,
				sort_order: orderedItems.length + index,
			}));
			queryClient.setQueryData<ListItem[]>(["list-items", listId], () => [
				...reorderedActive,
				...completedWithOrder,
			]);
			return { previousItems };
		},
		onError: (err, _variables, context) => {
			if (context?.previousItems && !isNetworkError(err)) {
				queryClient.setQueryData(["list-items", listId], context.previousItems);
			}
		},
	});

	// Handlers
	const handleAddItem = async (name: string) => {
		// Check for duplicates (case-insensitive) in active items
		const existingItem = items.find(
			(item) =>
				item.name.toLowerCase() === name.toLowerCase() && !item.is_bought,
		);

		if (existingItem) {
			setConflictState({
				isOpen: true,
				conflictingItem: existingItem,
				pendingName: name,
			});
			return;
		}

		createItemMutation.mutate({
			type: "create",
			data: {
				list_id: listId,
				name: name,
				quantity: null, // Default
				is_bought: false,
			},
		});
	};

	const resolveConflict = (combinedQuantity: string) => {
		if (!conflictState.conflictingItem) return;

		updateItemMutation.mutate({
			type: "update",
			data: {
				id: conflictState.conflictingItem.id,
				quantity: combinedQuantity,
			},
		});

		setConflictState({ isOpen: false });
	};

	const handleToggleItem = (id: string, isCompleted: boolean) => {
		updateItemMutation.mutate({
			type: "update",
			data: {
				id,
				is_bought: isCompleted,
			},
		});
	};

	const handleDeleteItem = (id: string) => {
		deleteItemMutation.mutate({
			type: "delete",
			itemId: id,
		});
	};

	const handleReorderItems = (orderedActiveItems: ListItem[]) => {
		// Only reorder active items; completed items stay at end
		reorderItemsMutation.mutate(orderedActiveItems);
	};

	const archiveList = async () => {
		await listsService.completeShoppingTrip(listId);
		queryClient.invalidateQueries({ queryKey: ["list", listId] });
		queryClient.invalidateQueries({ queryKey: ["list-items", listId] });
		queryClient.invalidateQueries({ queryKey: listQueryKeys.all });
	};

	const renameList = async (newName: string) => {
		const trimmed = newName.trim();
		if (!trimmed) return;
		await listsService.updateList(listId, { name: trimmed });
		queryClient.invalidateQueries({ queryKey: ["list", listId] });
		queryClient.invalidateQueries({ queryKey: listQueryKeys.all });
	};

	return {
		list,
		activeItems,
		completedItems,
		pendingIds,
		isLoading: isListLoading || isItemsLoading,
		error: listError,
		addItem: handleAddItem,
		toggleItem: handleToggleItem,
		deleteItem: handleDeleteItem,
		conflictState,
		resolveConflict,
		cancelConflict: () => setConflictState({ isOpen: false }),
		isSubmitting: createItemMutation.isPending || updateItemMutation.isPending,
		archiveList,
		renameList,
		reorderItems: handleReorderItems,
		isReordering: reorderItemsMutation.isPending,
	};
}



================================================
FILE: code/src/hooks/useListsView.ts
================================================
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { supabaseClient } from "@/db/supabase.client";
import { listItemsService } from "@/services/items.service";
import { listsService } from "@/services/lists.service";
import type { CreateListDTO, ListViewModel } from "@/types/domain.types";

/**
 * Query keys for lists-related queries
 */
export const listQueryKeys = {
	all: ["lists"] as const,
	detail: (id: string) => ["lists", id] as const,
};

/**
 * Custom hook for managing Lists View state and operations.
 * Handles fetching, creating, and deleting shopping lists with TanStack Query.
 */
export function useListsView() {
	const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
	const [currentUserId, setCurrentUserId] = useState<string | null>(null);
	const navigate = useNavigate();
	const queryClient = useQueryClient();

	// Fetch current user ID on mount
	useEffect(() => {
		const fetchUser = async () => {
			const {
				data: { user },
			} = await supabaseClient.auth.getUser();
			setCurrentUserId(user?.id ?? null);
		};
		fetchUser();
	}, []);

	// Query: Fetch all lists with item counts
	const listsQuery = useQuery({
		queryKey: listQueryKeys.all,
		queryFn: async (): Promise<ListViewModel[]> => {
			const lists = await listsService.getAllLists();

			// Fetch item counts for each list
			const listsWithCounts = await Promise.all(
				lists.map(async (list) => {
					try {
						const items = await listItemsService.getItemsByListId(list.id);
						return {
							...list,
							totalItems: items.length,
							boughtItems: items.filter((item) => item.is_bought).length,
							isShared: list.created_by !== currentUserId,
							ownerName: undefined, // TODO: Implement owner name fetching with join
						} as ListViewModel;
					} catch (error) {
						console.error(`Failed to fetch items for list ${list.id}:`, error);
						// Return list with zero counts if fetching items fails
						return {
							...list,
							totalItems: 0,
							boughtItems: 0,
							isShared: list.created_by !== currentUserId,
							ownerName: undefined,
						} as ListViewModel;
					}
				}),
			);

			return listsWithCounts;
		},
		staleTime: 30000, // 30 seconds
		enabled: !!currentUserId, // Only run query when we have a user ID
	});

	// Mutation: Create new list
	const createListMutation = useMutation({
		mutationFn: (data: CreateListDTO) => listsService.createList(data),
		onSuccess: () => {
			// Invalidate queries to refresh the list
			queryClient.invalidateQueries({ queryKey: listQueryKeys.all });
			// Close dialog
			setIsCreateDialogOpen(false);
			// Optional: Navigate to the newly created list
			// navigate({ to: `/lists/${newList.id}` });
		},
		onError: (error) => {
			console.error("Failed to create list:", error);
			// Error handling will be done in the component
		},
	});

	// Mutation: Delete list with optimistic updates
	const deleteListMutation = useMutation({
		mutationFn: (listId: string) => listsService.deleteList(listId),
		onMutate: async (listId) => {
			// Cancel any outgoing refetches
			await queryClient.cancelQueries({ queryKey: listQueryKeys.all });

			// Snapshot the previous value
			const previousLists = queryClient.getQueryData<ListViewModel[]>(
				listQueryKeys.all,
			);

			// Optimistically update to remove the list
			queryClient.setQueryData<ListViewModel[]>(
				listQueryKeys.all,
				(old) => old?.filter((list) => list.id !== listId) ?? [],
			);

			// Return context with the snapshot
			return { previousLists };
		},
		onError: (error, _listId, context) => {
			// Rollback on error
			if (context?.previousLists) {
				queryClient.setQueryData(listQueryKeys.all, context.previousLists);
			}
			console.error("Failed to delete list:", error);
		},
		onSettled: () => {
			// Refetch to sync with server
			queryClient.invalidateQueries({ queryKey: listQueryKeys.all });
		},
	});

	// Handlers
	const handleCreateList = async (data: CreateListDTO) => {
		await createListMutation.mutateAsync(data);
	};

	const handleDeleteList = async (listId: string) => {
		// Confirmation will be handled in the component
		await deleteListMutation.mutateAsync(listId);
	};

	const handleListClick = (listId: string) => {
		// Navigate to list details (future implementation)
		navigate({ to: `/lists/${listId}` });
	};

	return {
		// Data
		lists: listsQuery.data ?? [],
		isLoading: listsQuery.isLoading,
		error: listsQuery.error,
		currentUserId,

		// Dialog state
		isCreateDialogOpen,
		setIsCreateDialogOpen,

		// Handlers
		handleCreateList,
		handleDeleteList,
		handleListClick,

		// Loading states
		isCreating: createListMutation.isPending,
		isDeleting: deleteListMutation.isPending,

		// Refetch function
		refetch: listsQuery.refetch,
	};
}



================================================
FILE: code/src/hooks/useSetDetails.ts
================================================
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { setsService } from "@/services/sets.service";
import type { CreateSetItemDTO, SetItem } from "@/types/domain.types";

function isNetworkError(error: unknown): boolean {
	const err = error as { status?: number; message?: string; name?: string };
	return (
		!err?.status &&
		(err?.message === "Failed to fetch" ||
			err?.name === "TypeError" ||
			!navigator.onLine)
	);
}

export function useSetDetails(setId: string) {
	const queryClient = useQueryClient();
	const [pendingIds, setPendingIds] = useState<Set<string>>(new Set());

	const { data: set, isLoading: isSetLoading, error: setError } = useQuery({
		queryKey: ["set", setId],
		queryFn: () => setsService.getSetById(setId),
		enabled: !!setId,
		networkMode: "offlineFirst",
	});

	const { data: items = [], isLoading: isItemsLoading } = useQuery({
		queryKey: ["set-items", setId],
		queryFn: () => setsService.getSetItems(setId),
		enabled: !!setId,
		networkMode: "offlineFirst",
	});

	const addItemMutation = useMutation({
		mutationKey: ["set-items", "create", setId],
		scope: { id: `set-${setId}` },
		mutationFn: (data: CreateSetItemDTO) => setsService.addSetItem(data),
		networkMode: "offlineFirst",
		onMutate: async (newItem) => {
			const optimisticId = crypto.randomUUID();
			await queryClient.cancelQueries({ queryKey: ["set-items", setId] });
			const previousItems = queryClient.getQueryData<SetItem[]>([
				"set-items",
				setId,
			]);

			const maxSort =
				(previousItems?.length ?? 0) > 0
					? Math.max(
							...(previousItems ?? []).map((i) => i.sort_order ?? 0),
						) + 1
					: 0;

			queryClient.setQueryData<SetItem[]>(["set-items", setId], (old) => {
				const optimisticItem: SetItem = {
					id: optimisticId,
					set_id: setId,
					name: newItem.name,
					quantity: newItem.quantity ?? null,
					note: newItem.note ?? null,
					sort_order: newItem.sort_order ?? maxSort,
					created_at: new Date().toISOString(),
					updated_at: new Date().toISOString(),
				};
				return old ? [...old, optimisticItem] : [optimisticItem];
			});

			setPendingIds((prev) => new Set(prev).add(optimisticId));
			return { previousItems, optimisticId };
		},
		onError: (err, _variables, context) => {
			if (context?.previousItems && !isNetworkError(err)) {
				queryClient.setQueryData(
					["set-items", setId],
					context.previousItems,
				);
			}
		},
		onSettled: (_data, _error, _variables, context) => {
			if (context?.optimisticId) {
				setPendingIds((prev) => {
					const next = new Set(prev);
					next.delete(context.optimisticId);
					return next;
				});
			}
		},
	});

	const updateItemMutation = useMutation({
		mutationKey: ["set-items", "update", setId],
		scope: { id: `set-${setId}` },
		mutationFn: ({
			itemId,
			data,
		}: {
			itemId: string;
			data: Partial<CreateSetItemDTO>;
		}) => setsService.updateSetItem(itemId, data),
		networkMode: "offlineFirst",
		onMutate: async ({ itemId, data }) => {
			await queryClient.cancelQueries({ queryKey: ["set-items", setId] });
			const previousItems = queryClient.getQueryData<SetItem[]>([
				"set-items",
				setId,
			]);

			queryClient.setQueryData<SetItem[]>(["set-items", setId], (old) =>
				old?.map((item) =>
					item.id === itemId ? { ...item, ...data } : item,
				),
			);

			setPendingIds((prev) => new Set(prev).add(itemId));
			return { previousItems, itemId };
		},
		onError: (err, _variables, context) => {
			if (context?.previousItems && !isNetworkError(err)) {
				queryClient.setQueryData(
					["set-items", setId],
					context.previousItems,
				);
			}
		},
		onSettled: (_data, _error, _variables, context) => {
			if (context?.itemId) {
				setPendingIds((prev) => {
					const next = new Set(prev);
					next.delete(context.itemId);
					return next;
				});
			}
		},
	});

	const deleteItemMutation = useMutation({
		mutationKey: ["set-items", "delete", setId],
		scope: { id: `set-${setId}` },
		mutationFn: (itemId: string) => setsService.deleteSetItem(itemId),
		networkMode: "offlineFirst",
		onMutate: async (itemId) => {
			await queryClient.cancelQueries({ queryKey: ["set-items", setId] });
			const previousItems = queryClient.getQueryData<SetItem[]>([
				"set-items",
				setId,
			]);

			queryClient.setQueryData<SetItem[]>(["set-items", setId], (old) =>
				old?.filter((item) => item.id !== itemId),
			);

			setPendingIds((prev) => new Set(prev).add(itemId));
			return { previousItems, itemId };
		},
		onError: (err, _variables, context) => {
			if (context?.previousItems && !isNetworkError(err)) {
				queryClient.setQueryData(
					["set-items", setId],
					context.previousItems,
				);
			}
		},
		onSettled: (_data, _error, _variables, context) => {
			if (context?.itemId) {
				setPendingIds((prev) => {
					const next = new Set(prev);
					next.delete(context.itemId);
					return next;
				});
			}
		},
	});

	const addItem = (name: string) => {
		const trimmed = name.trim();
		if (!trimmed) return;

		const currentItems = queryClient.getQueryData<SetItem[]>([
			"set-items",
			setId,
		]);
		const maxSort =
			(currentItems?.length ?? 0) > 0
				? Math.max(...(currentItems ?? []).map((i) => i.sort_order ?? 0)) +
					1
				: 0;

		addItemMutation.mutate({
			set_id: setId,
			name: trimmed,
			sort_order: maxSort,
		});
	};

	const updateItem = (
		itemId: string,
		data: Partial<Pick<CreateSetItemDTO, "name" | "quantity" | "note">>,
	) => {
		updateItemMutation.mutate({ itemId, data });
	};

	const deleteItem = (itemId: string) => {
		deleteItemMutation.mutate(itemId);
	};

	const refetch = () => {
		queryClient.invalidateQueries({ queryKey: ["set", setId] });
		queryClient.invalidateQueries({ queryKey: ["set-items", setId] });
	};

	const renameSet = async (name: string) => {
		const trimmed = name.trim();
		if (!trimmed) return;
		await setsService.updateSet(setId, { name: trimmed });
		queryClient.invalidateQueries({ queryKey: ["set", setId] });
		queryClient.invalidateQueries({ queryKey: ["sets"] });
	};

	const deleteSet = async () => {
		await setsService.deleteSet(setId);
		queryClient.invalidateQueries({ queryKey: ["set", setId] });
		queryClient.invalidateQueries({ queryKey: ["set-items", setId] });
		queryClient.invalidateQueries({ queryKey: ["sets"] });
	};

	return {
		set: set ?? undefined,
		items,
		isLoading: isSetLoading || isItemsLoading,
		error: setError,
		addItem,
		updateItem,
		deleteItem,
		refetch,
		pendingIds,
		isSubmitting: addItemMutation.isPending || updateItemMutation.isPending,
		renameSet,
		deleteSet,
	};
}



================================================
FILE: code/src/hooks/useSetsView.ts
================================================
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { setsService } from "@/services/sets.service";
import type { CreateSetDTO } from "@/types/domain.types";

export const setQueryKeys = {
	all: ["sets"] as const,
	detail: (id: string) => ["sets", id] as const,
	items: (setId: string) => ["sets", setId, "items"] as const,
};

/**
 * Hook for Sets Dashboard: fetches all sets, createSet mutation.
 */
export function useSetsView() {
	const queryClient = useQueryClient();

	const {
		data: sets = [],
		isLoading,
		error,
		refetch,
	} = useQuery({
		queryKey: setQueryKeys.all,
		queryFn: () => setsService.getAllSets(),
		networkMode: "offlineFirst",
	});

	const createSetMutation = useMutation({
		mutationFn: (data: CreateSetDTO) => setsService.createSet(data),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: setQueryKeys.all });
		},
	});

	return {
		sets,
		isLoading,
		error,
		refetch: () => refetch(),
		queryClient,
		createSet: createSetMutation.mutateAsync,
		isCreatingSet: createSetMutation.isPending,
	};
}



================================================
FILE: code/src/integrations/tanstack-query/devtools.tsx
================================================
import { ReactQueryDevtoolsPanel } from "@tanstack/react-query-devtools";

export default {
	name: "Tanstack Query",
	render: <ReactQueryDevtoolsPanel />,
};



================================================
FILE: code/src/integrations/tanstack-query/root-provider.tsx
================================================
import { createSyncStoragePersister } from "@tanstack/query-sync-storage-persister";
import {
	MutationCache,
	onlineManager,
	QueryClient,
} from "@tanstack/react-query";
import { PersistQueryClientProvider } from "@tanstack/react-query-persist-client";
import { useEffect } from "react";
import { listItemsService } from "@/services/items.service";
import type {
	CreateListItemDTO,
	UpdateListItemDTO,
} from "@/types/domain.types";

// Create persister using localStorage
const persister = createSyncStoragePersister({
	storage: window.localStorage,
	key: "quickshop-query-cache",
});

// Define mutation function type that can handle all mutation types
type MutationVariables =
	| { type: "create"; data: CreateListItemDTO }
	| { type: "update"; data: UpdateListItemDTO }
	| { type: "delete"; itemId: string };

export function getContext() {
	const queryClient = new QueryClient({
		defaultOptions: {
			queries: {
				// Keep data in cache for 24 hours
				gcTime: 1000 * 60 * 60 * 24,
				// Consider data stale after 5 minutes
				staleTime: 1000 * 60 * 5,
				// Use offline-first mode for all queries
				networkMode: "offlineFirst",
				// Retry failed queries
				retry: 3,
				retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
				// Don't refetch on window focus by default (to avoid overwriting optimistic updates)
				refetchOnWindowFocus: false,
				// Don't refetch on reconnect (to avoid overwriting optimistic updates)
				refetchOnReconnect: false,
			},
			mutations: {
				// Use offline-first mode for all mutations
				networkMode: "offlineFirst",
				// Retry failed mutations
				retry: 3,
				retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
			},
		},
		// Add global mutation cache callbacks
		mutationCache: new MutationCache({
			onSuccess: (_data, _variables, _context, mutation) => {
				console.log(
					"[MutationCache] Mutation succeeded:",
					mutation.options.mutationKey,
				);
				// Invalidate queries after each successful mutation
				if (mutation.options.mutationKey?.[0] === "list-items") {
					const listId = mutation.options.mutationKey[2];
					if (listId) {
						console.log(
							"[MutationCache] Invalidating queries for list:",
							listId,
						);
						queryClient.invalidateQueries({ queryKey: ["list-items", listId] });
					}
				}
			},
			onError: (error, _variables, _context, mutation) => {
				console.error(
					"[MutationCache] Mutation failed:",
					mutation.options.mutationKey,
					error,
				);
			},
		}),
	});

	return {
		queryClient,
	};
}

export function Provider({
	children,
	queryClient,
}: {
	children: React.ReactNode;
	queryClient: QueryClient;
}) {
	// Set up online/offline detection with custom network check
	useEffect(() => {
		console.log("[QueryClient] Setting up custom online detection...");

		// Custom online check - try to reach Supabase
		const checkOnlineStatus = async () => {
			try {
				// Try a lightweight HEAD request to Supabase (won't count as query)
				const controller = new AbortController();
				const timeoutId = setTimeout(() => controller.abort(), 3000);

				const response = await fetch(
					"https://syjwmkiflgnxauitdrez.supabase.co/rest/v1/",
					{
						method: "HEAD",
						signal: controller.signal,
						cache: "no-store",
					},
				);

				clearTimeout(timeoutId);
				const isOnline = response.ok;
				console.log("[QueryClient] Network check result:", isOnline);
				return isOnline;
			} catch {
				console.log("[QueryClient] Network check failed - OFFLINE");
				return false;
			}
		};

		// Check online status immediately
		checkOnlineStatus().then((isOnline) => {
			onlineManager.setOnline(isOnline);
			console.log("[QueryClient] Initial online state:", isOnline);
		});

		// Set up event listener for online/offline detection
		const unsubscribe = onlineManager.setEventListener((setOnline) => {
			const handleOnline = async () => {
				console.log(
					"[QueryClient] Browser online event detected, verifying...",
				);
				const isReallyOnline = await checkOnlineStatus();
				setOnline(isReallyOnline);
			};

			const handleOffline = () => {
				console.log("[QueryClient] Browser went OFFLINE");
				setOnline(false);
			};

			window.addEventListener("online", handleOnline);
			window.addEventListener("offline", handleOffline);

			// Also check periodically when navigator says we're online but we might not be
			const intervalId = setInterval(async () => {
				if (navigator.onLine && !onlineManager.isOnline()) {
					// Navigator says online but we detected offline - recheck
					const isReallyOnline = await checkOnlineStatus();
					if (isReallyOnline) {
						console.log("[QueryClient] Network restored!");
						setOnline(true);
					}
				}
			}, 10000); // Check every 10 seconds

			return () => {
				window.removeEventListener("online", handleOnline);
				window.removeEventListener("offline", handleOffline);
				clearInterval(intervalId);
			};
		});

		return unsubscribe;
	}, []);

	// Set up mutation defaults BEFORE resuming paused mutations
	// This must be done in the Provider, not in getContext, so the function is available when mutations resume
	useEffect(() => {
		// Set mutation defaults with a global mutationFn
		// This is critical for offline-first - mutations can resume after page reload
		queryClient.setMutationDefaults(["list-items"], {
			networkMode: "offlineFirst",
			mutationFn: async (variables: MutationVariables) => {
				switch (variables.type) {
					case "create":
						return listItemsService.createItem(variables.data);
					case "update":
						return listItemsService.updateItem(variables.data);
					case "delete":
						return listItemsService.deleteItem(variables.itemId);
					default:
						throw new Error("Unknown mutation type");
				}
			},
		});
	}, [queryClient]);

	// Set up online event listener to resume paused mutations
	useEffect(() => {
		const handleOnline = () => {
			console.log("[QueryClient] Going online, resuming paused mutations...");
			// Resume paused mutations when coming back online
			queryClient.resumePausedMutations().then(() => {
				console.log("[QueryClient] All paused mutations resumed");
				// Wait a bit for mutations to complete before invalidating
				// This ensures optimistic updates are replaced with server data
				setTimeout(() => {
					console.log("[QueryClient] Invalidating queries after mutations");
					queryClient.invalidateQueries();
				}, 500);
			});
		};

		window.addEventListener("online", handleOnline);
		return () => window.removeEventListener("online", handleOnline);
	}, [queryClient]);

	return (
		<PersistQueryClientProvider
			client={queryClient}
			persistOptions={{
				persister,
				// Automatically persist mutations for offline support
				maxAge: 1000 * 60 * 60 * 24, // 24 hours
				// Dehydrate mutations to persist them
				dehydrateOptions: {
					shouldDehydrateMutation: () => true,
				},
			}}
			onSuccess={() => {
				console.log(
					"[QueryClient] Restored from localStorage, setting mutation defaults...",
				);
				// Set mutation defaults FIRST before resuming
				queryClient.setMutationDefaults(["list-items"], {
					networkMode: "offlineFirst",
					mutationFn: async (variables: MutationVariables) => {
						console.log("[QueryClient] Executing mutation:", variables.type);
						switch (variables.type) {
							case "create":
								return listItemsService.createItem(variables.data);
							case "update":
								return listItemsService.updateItem(variables.data);
							case "delete":
								return listItemsService.deleteItem(variables.itemId);
							default:
								throw new Error("Unknown mutation type");
						}
					},
				});

				console.log("[QueryClient] Resuming paused mutations after restore...");
				// Resume paused mutations after restore from localStorage
				// This is critical - without this, offline mutations won't be retried after page reload
				queryClient.resumePausedMutations().then(() => {
					console.log("[QueryClient] All restored mutations resumed");
					// Wait for mutations to complete before invalidating
					setTimeout(() => {
						console.log(
							"[QueryClient] Invalidating queries after restored mutations",
						);
						queryClient.invalidateQueries();
					}, 500);
				});
			}}
		>
			{children}
		</PersistQueryClientProvider>
	);
}



================================================
FILE: code/src/lib/utils.ts
================================================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}



================================================
FILE: code/src/routes/__root.tsx
================================================
import { TanStackDevtools } from "@tanstack/react-devtools";
import type { QueryClient } from "@tanstack/react-query";
import {
	createRootRouteWithContext,
	Outlet,
	useRouterState,
} from "@tanstack/react-router";
import { TanStackRouterDevtoolsPanel } from "@tanstack/react-router-devtools";
import { MainLayout } from "@/components/layout/MainLayout";
import TanStackQueryDevtools from "../integrations/tanstack-query/devtools";

interface MyRouterContext {
	queryClient: QueryClient;
}

export const Route = createRootRouteWithContext<MyRouterContext>()({
	component: RootComponent,
});

function isAppRoute(pathname: string) {
	return (
		pathname.startsWith("/lists") ||
		pathname.startsWith("/sets") ||
		pathname === "/history"
	);
}

function RootComponent() {
	const pathname = useRouterState({ select: (s) => s.location.pathname });
	const useMainLayout = isAppRoute(pathname);

	return (
		<>
			{useMainLayout ? (
				<MainLayout>
					<Outlet />
				</MainLayout>
			) : (
				<Outlet />
			)}
			<TanStackDevtools
				config={{
					position: "bottom-right",
				}}
				plugins={[
					{
						name: "Tanstack Router",
						render: <TanStackRouterDevtoolsPanel />,
					},
					TanStackQueryDevtools,
				]}
			/>
		</>
	);
}



================================================
FILE: code/src/routes/auth.tsx
================================================
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { AuthModeSwitch } from "@/components/auth/AuthModeSwitch";
import { EmailAuthForm } from "@/components/auth/EmailAuthForm";
import { GoogleAuthButton } from "@/components/auth/GoogleAuthButton";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { supabaseClient } from "@/db/supabase.client";
import type { AuthCredentials, AuthMode } from "@/types/auth.types";

export const Route = createFileRoute("/auth")({
	component: AuthView,
});

function AuthView() {
	const navigate = useNavigate();
	const [mode, setMode] = useState<AuthMode>("signin");
	const [isLoading, setIsLoading] = useState(false);
	const [error, setError] = useState<string | null>(null);

	// Check if user is already logged in
	useEffect(() => {
		const checkSession = async () => {
			const {
				data: { session },
			} = await supabaseClient.auth.getSession();
			if (session) {
				navigate({ to: "/lists" });
			}
		};
		checkSession();
	}, [navigate]);

	const getAuthErrorMessage = (
		supabaseError: { message: string; code?: string },
		isSignUp: boolean,
	) => {
		const msg = supabaseError.message.toLowerCase();
		const code = (supabaseError.code ?? "").toLowerCase();
		// Logowanie: konkretne komunikaty
		if (!isSignUp) {
			if (
				msg.includes("invalid login") ||
				msg.includes("invalid credentials") ||
				code.includes("invalid") ||
				msg.includes("invalid_credentials")
			)
				return "Nieprawidłowy email lub hasło.";
		}
		// Rejestracja: ogólny komunikat (bez ujawniania „użytkownik istnieje")
		if (isSignUp) {
			if (
				msg.includes("already registered") ||
				msg.includes("already exists") ||
				msg.includes("user_already_exists")
			)
				return "Nie udało się utworzyć konta. Sprawdź dane lub spróbuj zalogować się.";
		}
		// Fallback
		if (msg.includes("email") && msg.includes("confirm"))
			return "Sprawdź swoją skrzynkę pocztową, aby potwierdzić adres email.";
		return "Wystąpił błąd. Spróbuj ponownie.";
	};

	const handleEmailAuth = async (credentials: AuthCredentials) => {
		setIsLoading(true);
		setError(null);

		try {
			const result =
				mode === "signin"
					? await supabaseClient.auth.signInWithPassword({
							email: credentials.email,
							password: credentials.pass,
						})
					: await supabaseClient.auth.signUp({
							email: credentials.email,
							password: credentials.pass,
						});

			if (result.error) {
				setError(getAuthErrorMessage(result.error, mode === "signup"));
				return;
			}

			// Check if email confirmation is required
			if (mode === "signup" && result.data.user && !result.data.session) {
				setError(
					"Sprawdź swoją skrzynkę pocztową, aby potwierdzić adres email.",
				);
				return;
			}

			// Successful login/signup
			navigate({ to: "/lists" });
		} catch (err) {
			setError("Wystąpił nieoczekiwany błąd. Spróbuj ponownie.");
			console.error("Auth error:", err);
		} finally {
			setIsLoading(false);
		}
	};

	const handleGoogleAuth = async () => {
		setIsLoading(true);
		setError(null);

		try {
			const { error } = await supabaseClient.auth.signInWithOAuth({
				provider: "google",
				options: {
					redirectTo: `${window.location.origin}/lists`,
				},
			});

			if (error) {
				setError("Logowanie przez Google nie powiodło się. Spróbuj ponownie.");
			}
		} catch (err) {
			setError("Wystąpił nieoczekiwany błąd. Spróbuj ponownie.");
			console.error("Google auth error:", err);
		} finally {
			setIsLoading(false);
		}
	};

	return (
		<div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800 p-4">
			<Card className="w-full max-w-md">
				<CardHeader className="space-y-1">
					<CardTitle className="text-3xl font-bold text-center">
						QuickShop
					</CardTitle>
					<CardDescription className="text-center">
						Zarządzaj swoimi listami zakupów
					</CardDescription>
				</CardHeader>
				<CardContent className="space-y-4">
					<AuthModeSwitch
						currentMode={mode}
						onModeChange={(newMode) => {
							setMode(newMode);
							setError(null);
						}}
					/>

					{error && (
						<div
							className="flex items-start gap-2 p-3 text-sm text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/10 border border-red-200 dark:border-red-800 rounded-md"
							role="alert"
						>
							<span className="flex-1">{error}</span>
							<button
								type="button"
								onClick={() => setError(null)}
								className="shrink-0 rounded p-0.5 hover:bg-red-200/50 dark:hover:bg-red-800/30 focus:outline-none focus:ring-2 focus:ring-red-500"
								aria-label="Zamknij komunikat błędu"
							>
								<svg
									className="h-4 w-4"
									fill="none"
									stroke="currentColor"
									viewBox="0 0 24 24"
									aria-hidden
								>
									<title>Zamknij</title>
									<path
										strokeLinecap="round"
										strokeLinejoin="round"
										strokeWidth={2}
										d="M6 18L18 6M6 6l12 12"
									/>
								</svg>
							</button>
						</div>
					)}

					<EmailAuthForm
						mode={mode}
						onSubmit={handleEmailAuth}
						isLoading={isLoading}
					/>

					<div className="relative">
						<div className="absolute inset-0 flex items-center">
							<Separator />
						</div>
						<div className="relative flex justify-center text-xs uppercase">
							<span className="bg-white dark:bg-gray-950 px-2 text-gray-500">
								lub
							</span>
						</div>
					</div>

					<GoogleAuthButton onClick={handleGoogleAuth} isLoading={isLoading} />
				</CardContent>
			</Card>
		</div>
	);
}



================================================
FILE: code/src/routes/history.tsx
================================================
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect } from "react";
import { supabaseClient } from "@/db/supabase.client";

export const Route = createFileRoute("/history")({
	component: HistoryPage,
});

function HistoryPage() {
	const navigate = useNavigate();

	useEffect(() => {
		const checkAuth = async () => {
			const {
				data: { session },
			} = await supabaseClient.auth.getSession();
			if (!session) {
				navigate({ to: "/auth" });
			}
		};
		checkAuth();
	}, [navigate]);

	return (
		<div className="py-8 text-center text-muted-foreground">
			<p className="text-lg">Historia zakupów – wkrótce</p>
			<p className="mt-2 text-sm">Tu będzie lista zakończonych zakupów.</p>
		</div>
	);
}



================================================
FILE: code/src/routes/index.tsx
================================================
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect } from "react";
import { supabaseClient } from "@/db/supabase.client";

export const Route = createFileRoute("/")({
	component: IndexView,
});

function IndexView() {
	const navigate = useNavigate();

	useEffect(() => {
		const checkAuthAndRedirect = async () => {
			const {
				data: { session },
			} = await supabaseClient.auth.getSession();

			if (session) {
				navigate({ to: "/lists" });
			} else {
				navigate({ to: "/auth" });
			}
		};

		checkAuthAndRedirect();
	}, [navigate]);

	return (
		<div className="min-h-screen flex items-center justify-center">
			<div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900"></div>
		</div>
	);
}



================================================
FILE: code/src/routes/lists.$listId.tsx
================================================
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { ActiveItemsList } from "@/components/list-details/ActiveItemsList";
import { CompletedItemsSection } from "@/components/list-details/CompletedItemsSection";
import { ItemConflictDialog } from "@/components/list-details/ItemConflictDialog";
import { ListDetailsHeader } from "@/components/list-details/ListDetailsHeader";
import { StickyInputBar } from "@/components/list-details/StickyInputBar";
import { Button } from "@/components/ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { supabaseClient } from "@/db/supabase.client";
import { useListDetails } from "@/hooks/useListDetails";

export const Route = createFileRoute("/lists/$listId")({
	component: ListDetailsPage,
});

function ListDetailsPage() {
	const { listId } = Route.useParams();
	const navigate = useNavigate();
	const [archiveConfirmOpen, setArchiveConfirmOpen] = useState(false);
	const [sharePlaceholderOpen, setSharePlaceholderOpen] = useState(false);
	const [renameDialogOpen, setRenameDialogOpen] = useState(false);
	const [renameInputValue, setRenameInputValue] = useState("");
	const [createSetPlaceholderOpen, setCreateSetPlaceholderOpen] = useState(false);
	const [isArchiving, setIsArchiving] = useState(false);
	const [isRenaming, setIsRenaming] = useState(false);

	// Auth check
	useEffect(() => {
		const checkAuth = async () => {
			const {
				data: { session },
			} = await supabaseClient.auth.getSession();
			if (!session) {
				navigate({ to: "/auth" });
			}
		};
		checkAuth();
	}, [navigate]);

	const {
		list,
		activeItems,
		completedItems,
		pendingIds,
		isLoading,
		error,
		addItem,
		toggleItem,
		deleteItem,
		conflictState,
		resolveConflict,
		cancelConflict,
		isSubmitting,
		archiveList,
		renameList,
		reorderItems,
	} = useListDetails(listId);

	const handleArchiveConfirm = async () => {
		if (!archiveList) return;
		setIsArchiving(true);
		try {
			await archiveList();
			setArchiveConfirmOpen(false);
			navigate({ to: "/lists" });
		} catch (err) {
			console.error("Archive failed:", err);
		} finally {
			setIsArchiving(false);
		}
	};

	const handleRenameOpen = () => {
		setRenameInputValue(list?.name ?? "");
		setRenameDialogOpen(true);
	};

	const handleRenameConfirm = async () => {
		const trimmed = renameInputValue.trim();
		if (!trimmed || !renameList) return;
		setIsRenaming(true);
		try {
			await renameList(trimmed);
			setRenameDialogOpen(false);
		} catch (err) {
			console.error("Rename failed:", err);
		} finally {
			setIsRenaming(false);
		}
	};

	if (isLoading) {
		return (
			<div className="flex items-center justify-center min-h-screen">
				<div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
			</div>
		);
	}

	if (error || !list) {
		return (
			<div className="flex flex-col items-center justify-center min-h-screen text-center p-4">
				<p className="mb-4 text-red-600">
					Nie znaleziono listy lub wystąpił błąd.
				</p>
				<Button onClick={() => navigate({ to: "/lists" })} variant="outline">
					Wróć do list
				</Button>
			</div>
		);
	}

	return (
		<div className="flex flex-col min-h-screen pb-20 relative bg-background">
			<ListDetailsHeader
				list={list}
				onShare={() => setSharePlaceholderOpen(true)}
				onArchive={() => setArchiveConfirmOpen(true)}
				onCreateSet={() => setCreateSetPlaceholderOpen(true)}
				onRename={handleRenameOpen}
			/>

			<div className="flex-1 overflow-y-auto">
				<ActiveItemsList
					items={activeItems}
					onToggle={toggleItem}
					onDelete={deleteItem}
					onReorder={reorderItems}
					pendingIds={pendingIds}
				/>

				<CompletedItemsSection
					items={completedItems}
					onToggle={toggleItem}
					onDelete={deleteItem}
					pendingIds={pendingIds}
				/>
			</div>

			<StickyInputBar onAddItem={addItem} isSubmitting={isSubmitting} />

			<ItemConflictDialog
				isOpen={conflictState.isOpen}
				existingItem={conflictState.conflictingItem}
				newItemName={conflictState.pendingName}
				onConfirm={resolveConflict}
				onCancel={cancelConflict}
			/>

			{/* Archiwizacja: potwierdzenie */}
			<Dialog open={archiveConfirmOpen} onOpenChange={setArchiveConfirmOpen}>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Zakończ zakupy</DialogTitle>
						<DialogDescription>
							Czy na pewno chcesz zakończyć zakupy i zarchiwizować listę?
							Będziesz mógł ją zobaczyć w Historii.
						</DialogDescription>
					</DialogHeader>
					<DialogFooter>
						<Button
							variant="outline"
							onClick={() => setArchiveConfirmOpen(false)}
							disabled={isArchiving}
						>
							Anuluj
						</Button>
						<Button onClick={handleArchiveConfirm} disabled={isArchiving}>
							{isArchiving ? "Zapisywanie..." : "Zakończ zakupy"}
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>

			{/* Udostępnij: placeholder (ShareModal – część 8) */}
			<Dialog
				open={sharePlaceholderOpen}
				onOpenChange={setSharePlaceholderOpen}
			>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Udostępnij listę</DialogTitle>
						<DialogDescription>
							Udostępnianie listy – wkrótce (część 8).
						</DialogDescription>
					</DialogHeader>
					<DialogFooter>
						<Button onClick={() => setSharePlaceholderOpen(false)}>OK</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>

			{/* Zmień nazwę listy */}
			<Dialog open={renameDialogOpen} onOpenChange={setRenameDialogOpen}>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Zmień nazwę listy</DialogTitle>
						<DialogDescription>
							Wprowadź nową nazwę listy.
						</DialogDescription>
					</DialogHeader>
					<div className="grid gap-4 py-4">
						<div className="grid gap-2">
							<Label htmlFor="rename-list-input">Nazwa</Label>
							<Input
								id="rename-list-input"
								value={renameInputValue}
								onChange={(e) => setRenameInputValue(e.target.value)}
								placeholder="np. Zakupy tygodniowe"
								onKeyDown={(e) => {
									if (e.key === "Enter") {
										e.preventDefault();
										handleRenameConfirm();
									}
								}}
							/>
						</div>
					</div>
					<DialogFooter>
						<Button
							variant="outline"
							onClick={() => setRenameDialogOpen(false)}
							disabled={isRenaming}
						>
							Anuluj
						</Button>
						<Button
							onClick={handleRenameConfirm}
							disabled={isRenaming || !renameInputValue.trim()}
						>
							{isRenaming ? "Zapisywanie..." : "Zapisz"}
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>

			{/* Utwórz zestaw: placeholder (część zestawów) */}
			<Dialog
				open={createSetPlaceholderOpen}
				onOpenChange={setCreateSetPlaceholderOpen}
			>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Utwórz zestaw z listy</DialogTitle>
						<DialogDescription>
							Funkcja dostępna wkrótce (w ramach zakładki Zestawy).
						</DialogDescription>
					</DialogHeader>
					<DialogFooter>
						<Button onClick={() => setCreateSetPlaceholderOpen(false)}>
							OK
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>
		</div>
	);
}



================================================
FILE: code/src/routes/lists.index.tsx
================================================
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect } from "react";
import { CreateListDialog } from "@/components/lists/CreateListDialog";
import { ListsGrid } from "@/components/lists/ListsGrid";
import { ListsHeader } from "@/components/lists/ListsHeader";
import { Button } from "@/components/ui/button";
import { supabaseClient } from "@/db/supabase.client";
import { useListsView } from "@/hooks/useListsView";

export const Route = createFileRoute("/lists/")({
	component: ListsView,
});

function ListsView() {
	const navigate = useNavigate();

	// Check if user is authenticated
	useEffect(() => {
		const checkAuth = async () => {
			const {
				data: { session },
			} = await supabaseClient.auth.getSession();
			if (!session) {
				navigate({ to: "/auth" });
			}
		};
		checkAuth();
	}, [navigate]);

	// Use custom hook for lists management
	const {
		lists,
		isLoading,
		error,
		currentUserId,
		isCreateDialogOpen,
		setIsCreateDialogOpen,
		handleCreateList,
		handleDeleteList,
		handleListClick,
		isCreating,
		refetch,
	} = useListsView();

	return (
		<div className="space-y-6">
			<ListsHeader onCreateClick={() => setIsCreateDialogOpen(true)} />

			{/* Loading state */}
			{isLoading && (
				<div className="flex items-center justify-center py-12">
					<div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
				</div>
			)}

			{/* Error state */}
			{error && !isLoading && (
				<div className="flex flex-col items-center justify-center py-12 text-center">
					<p className="mb-4 text-red-600">
						Nie udało się pobrać list. Sprawdź połączenie z internetem.
					</p>
					<Button onClick={() => refetch()} variant="outline">
						Spróbuj ponownie
					</Button>
				</div>
			)}

			{/* Lists grid */}
			{!isLoading && !error && (
				<ListsGrid
					lists={lists}
					currentUserId={currentUserId}
					onListClick={handleListClick}
					onDeleteClick={handleDeleteList}
					onCreateClick={() => setIsCreateDialogOpen(true)}
				/>
			)}

			{/* Create list dialog */}
			<CreateListDialog
				isOpen={isCreateDialogOpen}
				onClose={() => setIsCreateDialogOpen(false)}
				onCreateList={handleCreateList}
				isCreating={isCreating}
			/>
		</div>
	);
}



================================================
FILE: code/src/routes/lists.tsx
================================================
import { createFileRoute, Outlet } from "@tanstack/react-router";

export const Route = createFileRoute("/lists")({
	component: () => <Outlet />,
});



================================================
FILE: code/src/routes/sets.$setId.tsx
================================================
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { SetDetailsHeader } from "@/components/set-details/SetDetailsHeader";
import { SetItemsList } from "@/components/set-details/SetItemsList";
import { StickyInputBar } from "@/components/list-details/StickyInputBar";
import { Button } from "@/components/ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { supabaseClient } from "@/db/supabase.client";
import { useSetDetails } from "@/hooks/useSetDetails";

export const Route = createFileRoute("/sets/$setId")({
	component: SetDetailsPage,
});

function SetDetailsPage() {
	const { setId } = Route.useParams();
	const navigate = useNavigate();
	const [renameDialogOpen, setRenameDialogOpen] = useState(false);
	const [renameValue, setRenameValue] = useState("");
	const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
	const [isRenaming, setIsRenaming] = useState(false);
	const [isDeleting, setIsDeleting] = useState(false);

	const {
		set,
		items,
		isLoading,
		error,
		addItem,
		updateItem,
		deleteItem,
		pendingIds,
		isSubmitting,
		renameSet,
		deleteSet,
	} = useSetDetails(setId);

	useEffect(() => {
		const checkAuth = async () => {
			const {
				data: { session },
			} = await supabaseClient.auth.getSession();
			if (!session) {
				navigate({ to: "/auth" });
			}
		};
		checkAuth();
	}, [navigate]);

	const handleRenameOpen = () => {
		setRenameValue(set?.name ?? "");
		setRenameDialogOpen(true);
	};

	const handleRenameConfirm = async () => {
		const trimmed = renameValue.trim();
		if (!trimmed || !renameSet) return;
		setIsRenaming(true);
		try {
			await renameSet(trimmed);
			setRenameDialogOpen(false);
		} catch (err) {
			console.error("Rename set failed:", err);
		} finally {
			setIsRenaming(false);
		}
	};

	const handleDeleteConfirm = async () => {
		if (!deleteSet) return;
		setIsDeleting(true);
		try {
			await deleteSet();
			setDeleteConfirmOpen(false);
			navigate({ to: "/sets" });
		} catch (err) {
			console.error("Delete set failed:", err);
		} finally {
			setIsDeleting(false);
		}
	};

	if (isLoading) {
		return (
			<div className="flex items-center justify-center min-h-screen">
				<div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
			</div>
		);
	}

	if (error || !set) {
		return (
			<div className="flex flex-col items-center justify-center min-h-screen text-center p-4">
				<p className="mb-4 text-red-600">
					Nie znaleziono zestawu lub wystąpił błąd.
				</p>
				<Button onClick={() => navigate({ to: "/sets" })} variant="outline">
					Wróć do zestawów
				</Button>
			</div>
		);
	}

	return (
		<div className="flex flex-col min-h-screen pb-20 relative bg-background">
			<SetDetailsHeader
				set={set}
				onRename={handleRenameOpen}
				onDeleteSet={() => setDeleteConfirmOpen(true)}
			/>

			<div className="flex-1 overflow-y-auto">
				<SetItemsList
					items={items}
					pendingIds={pendingIds}
					onUpdate={updateItem}
					onDelete={deleteItem}
				/>
			</div>

			<StickyInputBar onAddItem={addItem} isSubmitting={isSubmitting} />

			{/* Zmień nazwę zestawu */}
			<Dialog open={renameDialogOpen} onOpenChange={setRenameDialogOpen}>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Zmień nazwę zestawu</DialogTitle>
						<DialogDescription>
							Wprowadź nową nazwę zestawu (szablonu).
						</DialogDescription>
					</DialogHeader>
					<div className="grid gap-4 py-4">
						<div className="grid gap-2">
							<Label htmlFor="rename-set-input">Nazwa</Label>
							<Input
								id="rename-set-input"
								value={renameValue}
								onChange={(e) => setRenameValue(e.target.value)}
								placeholder="np. Śniadanie"
								onKeyDown={(e) => {
									if (e.key === "Enter") {
										e.preventDefault();
										handleRenameConfirm();
									}
								}}
							/>
						</div>
					</div>
					<DialogFooter>
						<Button
							variant="outline"
							onClick={() => setRenameDialogOpen(false)}
							disabled={isRenaming}
						>
							Anuluj
						</Button>
						<Button
							onClick={handleRenameConfirm}
							disabled={isRenaming || !renameValue.trim()}
						>
							{isRenaming ? "Zapisywanie..." : "Zapisz"}
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>

			{/* Usuń zestaw – potwierdzenie */}
			<Dialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
				<DialogContent className="sm:max-w-[425px]">
					<DialogHeader>
						<DialogTitle>Usuń zestaw</DialogTitle>
						<DialogDescription>
							Czy na pewno chcesz usunąć zestaw „{set.name}”? Ta operacja jest
							nieodwracalna.
						</DialogDescription>
					</DialogHeader>
					<DialogFooter>
						<Button
							variant="outline"
							onClick={() => setDeleteConfirmOpen(false)}
							disabled={isDeleting}
						>
							Anuluj
						</Button>
						<Button
							variant="destructive"
							onClick={handleDeleteConfirm}
							disabled={isDeleting}
						>
							{isDeleting ? "Usuwanie..." : "Usuń zestaw"}
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>
		</div>
	);
}



================================================
FILE: code/src/routes/sets.index.tsx
================================================
import { createFileRoute, useNavigate } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { AddSetToListDialog } from "@/components/sets/AddSetToListDialog";
import { CreateSetDialog } from "@/components/sets/CreateSetDialog";
import { SetsGrid } from "@/components/sets/SetsGrid";
import { SetsHeader } from "@/components/sets/SetsHeader";
import { Button } from "@/components/ui/button";
import { supabaseClient } from "@/db/supabase.client";
import { useSetsView } from "@/hooks/useSetsView";

export const Route = createFileRoute("/sets/")({
	component: SetsIndexPage,
});

function SetsIndexPage() {
	const navigate = useNavigate();
	const [addDialogOpen, setAddDialogOpen] = useState(false);
	const [addDialogSetId, setAddDialogSetId] = useState<string | null>(null);
	const [addDialogSetName, setAddDialogSetName] = useState("");
	const [createDialogOpen, setCreateDialogOpen] = useState(false);

	useEffect(() => {
		const checkAuth = async () => {
			const {
				data: { session },
			} = await supabaseClient.auth.getSession();
			if (!session) {
				navigate({ to: "/auth" });
			}
		};
		checkAuth();
	}, [navigate]);

	const {
		sets,
		isLoading,
		error,
		refetch,
		createSet,
		isCreatingSet,
	} = useSetsView();

	const handleAddToList = (setId: string) => {
		const set = sets.find((s) => s.id === setId);
		setAddDialogSetId(setId);
		setAddDialogSetName(set?.name ?? "");
		setAddDialogOpen(true);
	};

	const handleAddDialogClose = (open: boolean) => {
		setAddDialogOpen(open);
		if (!open) {
			setAddDialogSetId(null);
			setAddDialogSetName("");
		}
	};

	if (isLoading) {
		return (
			<div className="flex justify-center items-center min-h-[50vh]">
				<div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
			</div>
		);
	}

	if (error) {
		return (
			<div className="flex flex-col justify-center items-center py-12 text-center">
				<p className="mb-4 text-destructive">
					Nie udało się pobrać zestawów. Sprawdź połączenie z internetem.
				</p>
				<Button onClick={() => refetch()} variant="outline">
					Spróbuj ponownie
				</Button>
			</div>
		);
	}

	return (
		<div className="space-y-6">
			<SetsHeader onCreateClick={() => setCreateDialogOpen(true)} />

			<SetsGrid
				sets={sets}
				onAddToList={handleAddToList}
				onCreateSet={() => setCreateDialogOpen(true)}
				onSetClick={(setId) =>
					navigate({ to: "/sets/$setId", params: { setId } })
				}
			/>

			<AddSetToListDialog
				open={addDialogOpen}
				onOpenChange={handleAddDialogClose}
				setId={addDialogSetId}
				setName={addDialogSetName}
			/>

			<CreateSetDialog
				isOpen={createDialogOpen}
				onClose={() => setCreateDialogOpen(false)}
				onCreateSet={(data) => createSet(data)}
				isCreating={isCreatingSet}
			/>
		</div>
	);
}



================================================
FILE: code/src/routes/sets.tsx
================================================
import { createFileRoute, Outlet } from "@tanstack/react-router";

export const Route = createFileRoute("/sets")({
	component: () => <Outlet />,
});



================================================
FILE: code/src/routes/demo/tanstack-query.tsx
================================================
import { useQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/demo/tanstack-query")({
	component: TanStackQueryDemo,
});

function TanStackQueryDemo() {
	const { data } = useQuery({
		queryKey: ["todos"],
		queryFn: () =>
			Promise.resolve([
				{ id: 1, name: "Alice" },
				{ id: 2, name: "Bob" },
				{ id: 3, name: "Charlie" },
			]),
		initialData: [],
	});

	return (
		<div
			className="flex items-center justify-center min-h-screen bg-gradient-to-br from-purple-100 to-blue-100 p-4 text-white"
			style={{
				backgroundImage:
					"radial-gradient(50% 50% at 95% 5%, #f4a460 0%, #8b4513 70%, #1a0f0a 100%)",
			}}
		>
			<div className="w-full max-w-2xl p-8 rounded-xl backdrop-blur-md bg-black/50 shadow-xl border-8 border-black/10">
				<h1 className="text-2xl mb-4">
					TanStack Query Simple Promise Handling
				</h1>
				<ul className="mb-4 space-y-2">
					{data.map((todo) => (
						<li
							key={todo.id}
							className="bg-white/10 border border-white/20 rounded-lg p-3 backdrop-blur-sm shadow-md"
						>
							<span className="text-lg text-white">{todo.name}</span>
						</li>
					))}
				</ul>
			</div>
		</div>
	);
}



================================================
FILE: code/src/services/history.service.ts
================================================
import { supabaseClient } from "../db/supabase.client";
import type { HistoryEntry } from "../types/domain.types";

export interface IHistoryService {
	/**
	 * Fetches completed shopping trips.
	 */
	getHistory(): Promise<HistoryEntry[]>;
}

export class HistoryService implements IHistoryService {
	async getHistory(): Promise<HistoryEntry[]> {
		const { data, error } = await supabaseClient
			.from("shopping_history")
			.select("*")
			.order("completed_at", { ascending: false });

		if (error) throw error;
		return data;
	}
}

export const historyService = new HistoryService();



================================================
FILE: code/src/services/items.service.ts
================================================
import { supabaseClient } from "../db/supabase.client";
import type {
	CreateListItemDTO,
	ListItem,
	UpdateListItemDTO,
} from "../types/domain.types";

type UUID = string;

export interface IListItemsService {
	/**
	 * Fetches all items for a specific list.
	 */
	getItemsByListId(listId: UUID): Promise<ListItem[]>;

	/**
	 * Adds a single item to a list.
	 */
	createItem(data: CreateListItemDTO): Promise<ListItem>;

	/**
	 * Updates an item (toggle bought, change quantity, edit note).
	 */
	updateItem(data: UpdateListItemDTO): Promise<ListItem>;

	/**
	 * Deletes an item.
	 */
	deleteItem(itemId: UUID): Promise<void>;

	/**
	 * Updates the order of multiple items.
	 */
	reorderItems(items: { id: UUID; sort_order: number }[]): Promise<void>;

	/**
	 * Bulk creates items (used when importing from Sets).
	 */
	bulkCreateItems(items: CreateListItemDTO[]): Promise<ListItem[]>;
}

export class ListItemsService implements IListItemsService {
	async getItemsByListId(listId: UUID): Promise<ListItem[]> {
		const { data, error } = await supabaseClient
			.from("list_items")
			.select("*")
			.eq("list_id", listId)
			.order("sort_order", { ascending: true });

		if (error) throw error;
		return data;
	}

	async createItem(data: CreateListItemDTO): Promise<ListItem> {
		const { data: newItem, error } = await supabaseClient
			.from("list_items")
			.insert(data)
			.select()
			.single();

		if (error) throw error;
		return newItem;
	}

	async updateItem(data: UpdateListItemDTO): Promise<ListItem> {
		const { id, ...updates } = data;
		const { data: updatedItem, error } = await supabaseClient
			.from("list_items")
			.update(updates)
			.eq("id", id)
			.select()
			.single();

		if (error) throw error;
		return updatedItem;
	}

	async deleteItem(itemId: UUID): Promise<void> {
		const { error } = await supabaseClient
			.from("list_items")
			.delete()
			.eq("id", itemId);

		if (error) throw error;
	}

	async reorderItems(items: { id: UUID; sort_order: number }[]): Promise<void> {
		// Ideally we would use a bulk update (RPC or UPSERT with full data).
		// For MVP, handling partial updates via Promise.all is acceptable given the low volume.
		// Upsert fails for partial updates if required fields (name) are missing.
		const updates = items.map((item) =>
			supabaseClient
				.from("list_items")
				.update({ sort_order: item.sort_order })
				.eq("id", item.id),
		);

		const results = await Promise.all(updates);
		const error = results.find((r) => r.error)?.error;
		if (error) throw error;
	}

	async bulkCreateItems(items: CreateListItemDTO[]): Promise<ListItem[]> {
		const { data, error } = await supabaseClient
			.from("list_items")
			.insert(items)
			.select();

		if (error) throw error;
		return data;
	}
}

export const listItemsService = new ListItemsService();



================================================
FILE: code/src/services/lists.service.ts
================================================
import { supabaseClient } from "../db/supabase.client";
import type { CreateListDTO, ShoppingList } from "../types/domain.types";

type UUID = string;

export interface IListService {
	/**
	 * Fetches all lists the current user has access to (own + shared).
	 */
	getAllLists(): Promise<ShoppingList[]>;

	/**
	 * Fetches a single list details.
	 */
	getListById(listId: UUID): Promise<ShoppingList>;

	/**
	 * Creates a new shopping list.
	 */
	createList(data: CreateListDTO): Promise<ShoppingList>;

	/**
	 * Updates list metadata (e.g. name).
	 */
	updateList(listId: UUID, data: Partial<CreateListDTO>): Promise<ShoppingList>;

	/**
	 * Deletes a list permanently.
	 */
	deleteList(listId: UUID): Promise<void>;

	/**
	 * Shares a list with another user by email.
	 */
	shareListWithEmail(listId: UUID, email: string): Promise<void>;

	/**
	 * Completes the shopping trip.
	 */
	completeShoppingTrip(listId: UUID): Promise<void>;
}

export class ListsService implements IListService {
	async getAllLists(): Promise<ShoppingList[]> {
		// Get current user
		const {
			data: { user },
		} = await supabaseClient.auth.getUser();
		if (!user) throw new Error("User must be logged in");

		// Step 1: Get all list IDs the user has access to via list_members
		const { data: memberData, error: memberError } = await supabaseClient
			.from("list_members")
			.select("list_id")
			.eq("user_id", user.id);

		if (memberError) throw memberError;

		// If user has no lists, return empty array
		if (!memberData || memberData.length === 0) {
			return [];
		}

		// Extract list IDs
		const listIds = memberData.map((m) => m.list_id);

		// Step 2: Fetch the actual lists using the IDs
		const { data, error } = await supabaseClient
			.from("lists")
			.select("*")
			.in("id", listIds)
			.order("updated_at", { ascending: false });

		if (error) throw error;
		return data;
	}

	async getListById(listId: UUID): Promise<ShoppingList> {
		const { data, error } = await supabaseClient
			.from("lists")
			.select("*")
			.eq("id", listId)
			.single();

		if (error) throw error;
		return data;
	}

	async createList(data: CreateListDTO): Promise<ShoppingList> {
		const {
			data: { user },
			error: authError,
		} = await supabaseClient.auth.getUser();
		if (authError || !user)
			throw new Error("User must be logged in to create a list");

		// Step 1: Create the list
		const { data: newList, error } = await supabaseClient
			.from("lists")
			.insert({
				...data,
				created_by: user.id,
			})
			.select()
			.single();

		if (error) throw error;

		// Step 2: Add the creator as a member of the list using the function
		// We use invite_member_to_list instead of direct INSERT to avoid RLS recursion
		const { error: memberError } = await supabaseClient.rpc(
			"invite_member_to_list",
			{
				p_list_id: newList.id,
				p_user_id: user.id,
			},
		);

		if (memberError) {
			// If adding member fails, we should probably delete the list
			// to maintain consistency, but for now just throw the error
			console.error("Failed to add creator to list_members:", memberError);
			throw new Error("Failed to add user as list member. Please try again.");
		}

		return newList;
	}

	async updateList(
		listId: UUID,
		data: Partial<CreateListDTO>,
	): Promise<ShoppingList> {
		const { data: updatedList, error } = await supabaseClient
			.from("lists")
			.update(data)
			.eq("id", listId)
			.select()
			.single();

		if (error) throw error;
		return updatedList;
	}

	async deleteList(listId: UUID): Promise<void> {
		const { error } = await supabaseClient
			.from("lists")
			.delete()
			.eq("id", listId);

		if (error) throw error;
	}

	async shareListWithEmail(listId: UUID, email: string): Promise<void> {
		// 1. Find user by email
		const { data: users, error: userError } = await supabaseClient
			.from("profiles")
			.select("id")
			.eq("email", email)
			.limit(1);

		if (userError) throw userError;
		if (!users || users.length === 0) {
			throw new Error(`User with email ${email} not found.`);
		}

		const userId = users[0].id;

		// 2. Add to list_members using the function
		// We use invite_member_to_list instead of direct INSERT to:
		// - Avoid RLS recursion issues
		// - Allow existing members to invite others
		const { error: memberError } = await supabaseClient.rpc(
			"invite_member_to_list",
			{
				p_list_id: listId,
				p_user_id: userId,
			},
		);

		if (memberError) {
			// Check for duplicate key violation to avoid throwing if already shared
			if (memberError.message?.includes("already a member")) return;
			throw memberError;
		}
	}

	async completeShoppingTrip(listId: UUID): Promise<void> {
		const { error } = await supabaseClient.rpc("archive_list_items", {
			p_list_id: listId, // Parameter name matches the function definition in DB plan
		});

		if (error) throw error;
	}
}

export const listsService = new ListsService();



================================================
FILE: code/src/services/sets.service.ts
================================================
import { supabaseClient } from "../db/supabase.client";
import type {
	CreateSetDTO,
	CreateSetItemDTO,
	SetItem,
	ShoppingSet,
} from "../types/domain.types";

type UUID = string;

export interface ISetsService {
	/**
	 * Fetches all sets available to the user.
	 */
	getAllSets(): Promise<ShoppingSet[]>;

	/**
	 * Fetches a single set by ID (RLS ensures user has access via set_members).
	 */
	getSetById(setId: UUID): Promise<ShoppingSet>;

	/**
	 * Fetches items belonging to a specific set.
	 */
	getSetItems(setId: UUID): Promise<SetItem[]>;

	/**
	 * Creates a new empty set.
	 */
	createSet(data: CreateSetDTO): Promise<ShoppingSet>;

	/**
	 * Creates a new set populated with items from an existing list.
	 */
	createSetFromList(listId: UUID, data: CreateSetDTO): Promise<ShoppingSet>;

	/**
	 * Add items to a set.
	 */
	addSetItem(data: CreateSetItemDTO): Promise<SetItem>;

	/**
	 * Updates a set item.
	 */
	updateSetItem(
		itemId: UUID,
		data: Partial<CreateSetItemDTO>,
	): Promise<SetItem>;

	/**
	 * Deletes a set item.
	 */
	deleteSetItem(itemId: UUID): Promise<void>;

	/**
	 * Updates a set (name, description).
	 */
	updateSet(
		setId: UUID,
		data: Partial<Pick<ShoppingSet, "name" | "description">>,
	): Promise<ShoppingSet>;

	/**
	 * Deletes a set.
	 */
	deleteSet(setId: UUID): Promise<void>;
}

export class SetsService implements ISetsService {
	async getAllSets(): Promise<ShoppingSet[]> {
		// Same pattern as lists: query set_members first (no recursion), then sets by ID
		const {
			data: { user },
		} = await supabaseClient.auth.getUser();
		if (!user) throw new Error("User must be logged in");

		const { data: memberData, error: memberError } = await supabaseClient
			.from("set_members")
			.select("set_id")
			.eq("user_id", user.id);

		if (memberError) throw memberError;
		if (!memberData || memberData.length === 0) return [];

		const setIds = memberData.map((m) => m.set_id);

		const { data, error } = await supabaseClient
			.from("sets")
			.select("*")
			.in("id", setIds)
			.order("name", { ascending: true });

		if (error) throw error;
		return data;
	}

	async getSetById(setId: UUID): Promise<ShoppingSet> {
		const { data, error } = await supabaseClient
			.from("sets")
			.select("*")
			.eq("id", setId)
			.single();

		if (error) throw error;
		return data;
	}

	async getSetItems(setId: UUID): Promise<SetItem[]> {
		const { data, error } = await supabaseClient
			.from("set_items")
			.select("*")
			.eq("set_id", setId)
			.order("sort_order", { ascending: true });

		if (error) throw error;
		return data;
	}

	async createSet(data: CreateSetDTO): Promise<ShoppingSet> {
		const {
			data: { user },
			error: authError,
		} = await supabaseClient.auth.getUser();
		if (authError || !user)
			throw new Error("User must be logged in to create a set");

		const { data: newSet, error } = await supabaseClient
			.from("sets")
			.insert({
				...data,
				created_by: user.id,
			})
			.select()
			.single();

		if (error) throw error;

		// Add creator to set_members (avoids RLS recursion; same pattern as lists)
		const { error: memberError } = await supabaseClient.rpc(
			"invite_member_to_set",
			{
				p_set_id: newSet.id,
				p_user_id: user.id,
			},
		);

		if (memberError) {
			console.error("Failed to add creator to set_members:", memberError);
			throw new Error(
				"Nie udało się dodać użytkownika do zestawu. Spróbuj ponownie.",
			);
		}

		return newSet;
	}

	async createSetFromList(
		listId: UUID,
		data: CreateSetDTO,
	): Promise<ShoppingSet> {
		// 1. Fetch List Items
		const { data: listItems, error: listError } = await supabaseClient
			.from("list_items")
			.select("*")
			.eq("list_id", listId);

		if (listError) throw listError;

		// 2. Create Set
		const newSet = await this.createSet(data);

		if (!listItems || listItems.length === 0) {
			return newSet;
		}

		// 3. Transform to Set Items
		const setItemsPayload = listItems.map((item) => ({
			set_id: newSet.id,
			name: item.name,
			quantity: item.quantity,
			note: item.note,
			sort_order: item.sort_order,
		}));

		// 4. Bulk Insert
		const { error: insertError } = await supabaseClient
			.from("set_items")
			.insert(setItemsPayload);

		if (insertError) {
			// In a real app we might want to rollback the set creation here
			throw insertError;
		}

		return newSet;
	}

	async addSetItem(data: CreateSetItemDTO): Promise<SetItem> {
		const { data: newItem, error } = await supabaseClient
			.from("set_items")
			.insert(data)
			.select()
			.single();

		if (error) throw error;
		return newItem;
	}

	async updateSetItem(
		itemId: UUID,
		data: Partial<CreateSetItemDTO>,
	): Promise<SetItem> {
		const { data: updatedItem, error } = await supabaseClient
			.from("set_items")
			.update(data)
			.eq("id", itemId)
			.select()
			.single();

		if (error) throw error;
		return updatedItem;
	}

	async deleteSetItem(itemId: UUID): Promise<void> {
		const { error } = await supabaseClient
			.from("set_items")
			.delete()
			.eq("id", itemId);

		if (error) throw error;
	}

	async updateSet(
		setId: UUID,
		data: Partial<Pick<ShoppingSet, "name" | "description">>,
	): Promise<ShoppingSet> {
		const { data: updatedSet, error } = await supabaseClient
			.from("sets")
			.update(data)
			.eq("id", setId)
			.select()
			.single();

		if (error) throw error;
		return updatedSet;
	}

	async deleteSet(setId: UUID): Promise<void> {
		const { error } = await supabaseClient
			.from("sets")
			.delete()
			.eq("id", setId);

		if (error) throw error;
	}
}

export const setsService = new SetsService();



================================================
FILE: code/src/types/auth.types.ts
================================================
// Types for authentication views and forms

export type AuthMode = "signin" | "signup";

export interface AuthCredentials {
	email: string;
	pass: string; // "pass" instead of "password" to avoid collision with HTML attributes
}

export interface AuthError {
	message: string;
	code?: string;
}



================================================
FILE: code/src/types/domain.types.ts
================================================
import type { Database } from "../db/database.types";

// Primitive Types aliases for clarity
type UUID = string;

// Domain Entities
export type Profile = Database["public"]["Tables"]["profiles"]["Row"];
export type ShoppingList = Database["public"]["Tables"]["lists"]["Row"];
export type ListItem = Database["public"]["Tables"]["list_items"]["Row"];
export type ShoppingSet = Database["public"]["Tables"]["sets"]["Row"];
export type SetItem = Database["public"]["Tables"]["set_items"]["Row"];
export type HistoryEntry =
	Database["public"]["Tables"]["shopping_history"]["Row"];

// DTOs (Data Transfer Objects) for creating/updating
export interface CreateListDTO {
	name: string;
}

export interface CreateListItemDTO {
	list_id: UUID;
	name: string;
	quantity?: string | null;
	note?: string | null;
	is_bought?: boolean;
	sort_order?: number;
}

export interface UpdateListItemDTO {
	id: UUID;
	name?: string;
	quantity?: string | null;
	note?: string | null;
	is_bought?: boolean;
	sort_order?: number;
}

export interface CreateSetDTO {
	name: string;
	description?: string | null;
}

export interface CreateSetItemDTO {
	set_id: UUID;
	name: string;
	quantity?: string | null;
	note?: string | null;
	sort_order?: number;
}

// ViewModels for UI components
/**
 * ViewModel for a single list in the Lists View.
 * Extends ShoppingList with additional fields needed for display.
 */
export interface ListViewModel extends ShoppingList {
	/**
	 * Total number of products on the list (bought + unbought)
	 */
	totalItems: number;

	/**
	 * Number of products marked as bought
	 */
	boughtItems: number;

	/**
	 * Whether the list is shared with other users
	 * (true if created_by !== current_user_id)
	 */
	isShared: boolean;

	/**
	 * Optional: owner's name (to display if isShared === true)
	 * Requires join with profiles table
	 */
	ownerName?: string;
}

// Reprezentacja stanu konfliktu przy dodawaniu zestawu
export interface SetConflictItem {
	existingItem: ListItem;
	newItemCandidate: CreateListItemDTO;
	// Sugerowana nowa ilość (np. konkatenacja stringów)
	suggestedQuantity: string;
}

// Wynik rozwiązania konfliktu zestawu
export interface SetResolutionResult {
	itemsToCreate: CreateListItemDTO[]; // Produkty bez konfliktów + zaakceptowane nowe
	itemsToUpdate: { itemId: UUID; newQuantity: string }[]; // Produkty zaktualizowane
}

// Stan modala konfliktu pojedynczego
export interface SingleItemConflictState {
	isOpen: boolean;
	conflictingItem?: ListItem;
	pendingName?: string; // Nazwa którą użytkownik próbował dodać
}



================================================
FILE: code/supabase/APPLY_FIX.sql
================================================
-- ============================================================================
-- FIX FOR INFINITE RECURSION IN list_members RLS POLICIES
-- ============================================================================
-- Instructions:
-- 1. Go to your Supabase Dashboard
-- 2. Navigate to SQL Editor
-- 3. Copy and paste this entire script
-- 4. Click "Run" to execute
-- ============================================================================

-- Drop existing problematic policies
drop policy if exists "Users can view members of their lists" on public.list_members;
drop policy if exists "Members can add new members" on public.list_members;
drop policy if exists "Members can remove members" on public.list_members;

-- New SELECT policy: Users can view members of lists they created or are members of
-- This checks the lists table directly instead of recursively checking list_members
create policy "Users can view members of their lists"
  on public.list_members for select
  to authenticated
  using (
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
    or
    -- User is a member of the list (direct check, no subquery on list_members)
    user_id = auth.uid()
  );

-- New INSERT policy: Only list creators or existing members can add new members
-- Uses the lists table to check ownership, avoiding recursion
create policy "Members can add new members"
  on public.list_members for insert
  to authenticated
  with check (
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
    or
    -- User is already a member (this is safe because it's checking the row being inserted)
    exists (
      select 1 from public.list_members 
      where list_id = list_members.list_id 
      and user_id = auth.uid()
    )
  );

-- New DELETE policy: Users can remove themselves or list creators can remove anyone
create policy "Members can remove members"
  on public.list_members for delete
  to authenticated
  using (
    -- User is removing themselves
    user_id = auth.uid()
    or
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
  );

-- ============================================================================
-- VERIFICATION
-- ============================================================================
-- After running this script, you should be able to:
-- 1. Create new lists without errors
-- 2. View your lists
-- 3. Share lists with other users
-- 
-- The infinite recursion error should be resolved!
-- ============================================================================



================================================
FILE: code/supabase/APPLY_FIX_COMPLETE.sql
================================================
-- ============================================================================
-- COMPLETE FIX FOR INFINITE RECURSION IN RLS POLICIES
-- ============================================================================
-- This script fixes BOTH list_members AND lists table policies
-- Apply this in your Supabase SQL Editor
-- ============================================================================

-- ============================================================================
-- PART 1: Fix list_members policies
-- ============================================================================

-- Drop existing problematic list_members policies
drop policy if exists "Users can view members of their lists" on public.list_members;
drop policy if exists "Members can add new members" on public.list_members;
drop policy if exists "Members can remove members" on public.list_members;

-- New SELECT policy: Users can view members of lists they created or are members of
create policy "Users can view members of their lists"
  on public.list_members for select
  to authenticated
  using (
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
    or
    -- User is a member of the list (direct check)
    user_id = auth.uid()
  );

-- New INSERT policy: Only list creators or existing members can add new members
create policy "Members can add new members"
  on public.list_members for insert
  to authenticated
  with check (
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
    or
    -- User is already a member
    exists (
      select 1 from public.list_members 
      where list_id = list_members.list_id 
      and user_id = auth.uid()
    )
  );

-- New DELETE policy: Users can remove themselves or list creators can remove anyone
create policy "Members can remove members"
  on public.list_members for delete
  to authenticated
  using (
    -- User is removing themselves
    user_id = auth.uid()
    or
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
  );

-- ============================================================================
-- PART 2: Fix lists policies
-- ============================================================================

-- Drop existing lists policies
drop policy if exists "Users can view their lists" on public.lists;
drop policy if exists "Users can update their lists" on public.lists;
drop policy if exists "Users can delete their lists" on public.lists;
drop policy if exists "Users can create lists" on public.lists;

-- New SELECT policy: Users can view lists they created
create policy "Users can view their lists"
  on public.lists for select
  to authenticated
  using (
    created_by = auth.uid()
  );

-- New UPDATE policy: Only creators can update list metadata
create policy "Users can update their lists"
  on public.lists for update
  to authenticated
  using (
    created_by = auth.uid()
  );

-- New DELETE policy: Only creators can delete lists
create policy "Users can delete their lists"
  on public.lists for delete
  to authenticated
  using (
    created_by = auth.uid()
  );

-- INSERT policy: Authenticated users can create lists
create policy "Users can create lists"
  on public.lists for insert
  to authenticated
  with check (auth.uid() = created_by);

-- ============================================================================
-- VERIFICATION
-- ============================================================================
-- After running this script:
-- ✅ You can create new lists
-- ✅ You can view your own lists
-- ✅ You can delete your lists
-- ✅ No infinite recursion errors
--
-- Note: The frontend code has been updated to handle shared lists by
-- querying list_members first, then fetching the lists.
-- ============================================================================



================================================
FILE: code/supabase/FIX_EXISTING_LISTS.sql
================================================
-- ============================================================================
-- FIX EXISTING LISTS - Add creators to list_members
-- ============================================================================
-- This script adds list creators to list_members for any lists where they're missing
-- Run this in Supabase SQL Editor to fix existing lists
-- ============================================================================

-- Insert missing list_members entries for list creators
-- This will add the creator as a member for any list where they're not already a member
insert into public.list_members (list_id, user_id)
select l.id, l.created_by
from public.lists l
where not exists (
  select 1 
  from public.list_members lm 
  where lm.list_id = l.id 
  and lm.user_id = l.created_by
)
on conflict (list_id, user_id) do nothing;

-- Verify the fix
-- This should show how many rows were added
select 
  'Fixed ' || count(*) || ' lists' as result
from public.lists l
where exists (
  select 1 
  from public.list_members lm 
  where lm.list_id = l.id 
  and lm.user_id = l.created_by
);

-- ============================================================================
-- After running this:
-- 1. All existing lists will have their creators as members
-- 2. Lists will now show up in the UI
-- 3. Future lists will automatically get this through the updated createList code
-- ============================================================================



================================================
FILE: code/supabase/migrations/20260128120000_initial_schema.sql
================================================
-- 20260128120000_initial_schema.sql
-- Migration: Initial Schema Setup for QuickShop
-- Description: Creates profiles, lists, sets, items, history tables with RLS and triggers.

-- Table: public.profiles
-- Purpose: Stores public user information. Linked to auth.users.
create table public.profiles (
  id uuid not null references auth.users(id) on delete cascade,
  full_name text,
  email text,
  updated_at timestamp with time zone default now(),
  constraint profiles_pkey primary key (id)
);

comment on table public.profiles is 'Public user profiles linked to auth.users.';

-- Enable RLS for profiles
alter table public.profiles enable row level security;

-- Table: public.lists
-- Purpose: Stores shopping lists.
create table public.lists (
  id uuid not null default gen_random_uuid(),
  name text not null,
  created_by uuid not null references auth.users(id),
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  constraint lists_pkey primary key (id)
);

comment on table public.lists is 'Main shopping lists.';

-- Enable RLS for lists
alter table public.lists enable row level security;

-- Table: public.list_members
-- Purpose: Manages many-to-many relationship between users and lists (sharing).
create table public.list_members (
  list_id uuid not null references public.lists(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamp with time zone default now(),
  constraint list_members_pkey primary key (list_id, user_id)
);

comment on table public.list_members is 'Junction table for list sharing.';

-- Enable RLS for list_members
alter table public.list_members enable row level security;

-- Table: public.list_items
-- Purpose: Stores items within a shopping list.
create table public.list_items (
  id uuid not null default gen_random_uuid(),
  list_id uuid not null references public.lists(id) on delete cascade,
  name text not null,
  quantity text,
  note text,
  is_bought boolean default false,
  sort_order double precision default 0.0,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  constraint list_items_pkey primary key (id)
);

comment on table public.list_items is 'Individual items in a shopping list.';

-- Enable RLS for list_items
alter table public.list_items enable row level security;

-- Table: public.sets
-- Purpose: Templates/Sets for shopping lists.
create table public.sets (
  id uuid not null default gen_random_uuid(),
  name text not null,
  description text,
  created_by uuid not null references auth.users(id),
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  constraint sets_pkey primary key (id)
);

comment on table public.sets is 'Shopping list templates (sets).';

-- Enable RLS for sets
alter table public.sets enable row level security;

-- Table: public.set_members
-- Purpose: Manages sharing of sets.
create table public.set_members (
  set_id uuid not null references public.sets(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamp with time zone default now(),
  constraint set_members_pkey primary key (set_id, user_id)
);

comment on table public.set_members is 'Junction table for set sharing.';

-- Enable RLS for set_members
alter table public.set_members enable row level security;

-- Table: public.set_items
-- Purpose: Items within a set.
create table public.set_items (
  id uuid not null default gen_random_uuid(),
  set_id uuid not null references public.sets(id) on delete cascade,
  name text not null,
  quantity text,
  note text,
  sort_order double precision default 0.0,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  constraint set_items_pkey primary key (id)
);

comment on table public.set_items is 'Items within a template set.';

-- Enable RLS for set_items
alter table public.set_items enable row level security;

-- Table: public.shopping_history
-- Purpose: Archives completed shopping trips.
create table public.shopping_history (
  id uuid not null default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  list_name text not null,
  items_snapshot jsonb not null,
  completed_at timestamp with time zone default now(),
  constraint shopping_history_pkey primary key (id)
);

comment on table public.shopping_history is 'Archive of completed shopping lists.';

-- Enable RLS for shopping_history
alter table public.shopping_history enable row level security;

-- Indexes for performance
-- List items filtering
create index idx_list_items_list_id on public.list_items(list_id);
-- List access checks
create index idx_list_members_user_id on public.list_members(user_id);
create index idx_list_members_list_id on public.list_members(list_id);
-- Set items filtering
create index idx_set_items_set_id on public.set_items(set_id);
-- Set access checks
create index idx_set_members_user_id on public.set_members(user_id);
create index idx_set_members_set_id on public.set_members(set_id);
-- History filtering and sorting
create index idx_shopping_history_user_id on public.shopping_history(user_id);
create index idx_shopping_history_completed_at on public.shopping_history(completed_at);

-- Function: update_updated_at
-- Purpose: Automatically updates the updated_at column on update.
create or replace function public.update_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Trigger: update_updated_at for profiles
create trigger update_profiles_updated_at
  before update on public.profiles
  for each row execute function public.update_updated_at();

-- Trigger: update_updated_at for lists
create trigger update_lists_updated_at
  before update on public.lists
  for each row execute function public.update_updated_at();

-- Trigger: update_updated_at for list_items
create trigger update_list_items_updated_at
  before update on public.list_items
  for each row execute function public.update_updated_at();

-- Trigger: update_updated_at for sets
create trigger update_sets_updated_at
  before update on public.sets
  for each row execute function public.update_updated_at();

-- Trigger: update_updated_at for set_items
create trigger update_set_items_updated_at
  before update on public.set_items
  for each row execute function public.update_updated_at();

-- Function: handle_new_user
-- Purpose: Creates a profile and a default list for new users.
create or replace function public.handle_new_user()
returns trigger
security definer set search_path = public
as $$
declare
  new_list_id uuid;
begin
  -- Create profile
  insert into public.profiles (id, full_name, email)
  values (new.id, new.raw_user_meta_data->>'full_name', new.email);

  -- Create default list
  insert into public.lists (name, created_by)
  values ('Moja pierwsza lista', new.id)
  returning id into new_list_id;

  -- Add user to list members
  insert into public.list_members (list_id, user_id)
  values (new_list_id, new.id);

  return new;
end;
$$ language plpgsql;

-- Trigger: on_auth_user_created
-- Purpose: Triggers handle_new_user when a new user is created in auth.users.
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- Function: archive_list_items
-- Purpose: Moves bought items to history and removes them from the list.
create or replace function public.archive_list_items(p_list_id uuid)
returns void
security definer set search_path = public
as $$
declare
  v_list_name text;
  v_items jsonb;
  v_user_id uuid;
begin
  -- Get current user id
  v_user_id := auth.uid();

  -- Verify user is a member of the list
  if not exists (select 1 from public.list_members where list_id = p_list_id and user_id = v_user_id) then
    raise exception 'Access denied';
  end if;

  -- Get list name
  select name into v_list_name from public.lists where id = p_list_id;

  -- Get bought items as jsonb
  select jsonb_agg(jsonb_build_object(
    'name', name,
    'quantity', quantity,
    'note', note
  ))
  into v_items
  from public.list_items
  where list_id = p_list_id and is_bought = true;

  -- If no items to archive, exit
  if v_items is null then
    return;
  end if;

  -- Create history record
  insert into public.shopping_history (user_id, list_name, items_snapshot)
  values (v_user_id, v_list_name, v_items);

  -- Delete archived items
  delete from public.list_items
  where list_id = p_list_id and is_bought = true;

end;
$$ language plpgsql;


-- RLS Policies

-- --- profiles ---
-- Select: Any authenticated user can view profiles (to find users to share with).
create policy "Profiles are viewable by everyone authenticated"
  on public.profiles for select
  to authenticated
  using (true);

-- Update: Users can update their own profile.
create policy "Users can update own profile"
  on public.profiles for update
  to authenticated
  using (auth.uid() = id);

-- Insert: Handled by system trigger, no manual insert needed for now.
-- But typically we might allow it if auto-creation fails? Stick to trigger for consistency.

-- --- lists ---
-- Select: Users can view lists they are members of.
create policy "Users can view their lists"
  on public.lists for select
  to authenticated
  using (
    auth.uid() in (
      select user_id from public.list_members where list_id = id
    )
  );

-- Update: Users can update lists they are members of.
create policy "Users can update their lists"
  on public.lists for update
  to authenticated
  using (
    auth.uid() in (
      select user_id from public.list_members where list_id = id
    )
  );

-- Delete: Users can delete lists they are members of.
create policy "Users can delete their lists"
  on public.lists for delete
  to authenticated
  using (
    auth.uid() in (
      select user_id from public.list_members where list_id = id
    )
  );

-- Insert: Authenticated users can create lists.
create policy "Users can create lists"
  on public.lists for insert
  to authenticated
  with check (auth.uid() = created_by);


-- --- list_members ---
-- Select: Users can view members of lists they belong to.
create policy "Users can view members of their lists"
  on public.list_members for select
  to authenticated
  using (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );

-- Insert: Members can add other members (share list).
create policy "Members can add new members"
  on public.list_members for insert
  to authenticated
  with check (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );

-- Delete: Members can remove members (unshare or leave).
create policy "Members can remove members"
  on public.list_members for delete
  to authenticated
  using (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );


-- --- list_items ---
-- Select: Users can view items of lists they belong to.
create policy "Users can view list items"
  on public.list_items for select
  to authenticated
  using (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );

-- Insert: Users can add items to lists they belong to.
create policy "Users can add list items"
  on public.list_items for insert
  to authenticated
  with check (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );

-- Update: Users can update items in lists they belong to.
create policy "Users can update list items"
  on public.list_items for update
  to authenticated
  using (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );

-- Delete: Users can delete items from lists they belong to.
create policy "Users can delete list items"
  on public.list_items for delete
  to authenticated
  using (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );


-- --- sets ---
-- Select: Users can view sets they are members of.
create policy "Users can view their sets"
  on public.sets for select
  to authenticated
  using (
    auth.uid() in (
      select user_id from public.set_members where set_id = id
    )
  );

-- Update: Users can update sets they are members of.
create policy "Users can update their sets"
  on public.sets for update
  to authenticated
  using (
    auth.uid() in (
      select user_id from public.set_members where set_id = id
    )
  );

-- Delete: Users can delete sets they are members of.
create policy "Users can delete their sets"
  on public.sets for delete
  to authenticated
  using (
    auth.uid() in (
      select user_id from public.set_members where set_id = id
    )
  );

-- Insert: Authenticated users can create sets.
create policy "Users can create sets"
  on public.sets for insert
  to authenticated
  with check (auth.uid() = created_by);


-- --- set_members ---
-- Select: Users can view members of sets they belong to.
create policy "Users can view members of their sets"
  on public.set_members for select
  to authenticated
  using (
    set_id in (
      select set_id from public.set_members where user_id = auth.uid()
    )
  );

-- Insert: Members can add other members (share set).
create policy "Members can add new set members"
  on public.set_members for insert
  to authenticated
  with check (
    set_id in (
      select set_id from public.set_members where user_id = auth.uid()
    )
  );

-- Delete: Members can remove members from sets.
create policy "Members can remove set members"
  on public.set_members for delete
  to authenticated
  using (
    set_id in (
      select set_id from public.set_members where user_id = auth.uid()
    )
  );


-- --- set_items ---
-- Select: Users can view items of sets they belong to.
create policy "Users can view set items"
  on public.set_items for select
  to authenticated
  using (
    set_id in (
      select set_id from public.set_members where user_id = auth.uid()
    )
  );

-- Insert: Users can add items to sets they belong to.
create policy "Users can add set items"
  on public.set_items for insert
  to authenticated
  with check (
    set_id in (
      select set_id from public.set_members where user_id = auth.uid()
    )
  );

-- Update: Users can update items in sets they belong to.
create policy "Users can update set items"
  on public.set_items for update
  to authenticated
  using (
    set_id in (
      select set_id from public.set_members where user_id = auth.uid()
    )
  );

-- Delete: Users can delete items from sets they belong to.
create policy "Users can delete set items"
  on public.set_items for delete
  to authenticated
  using (
    set_id in (
      select set_id from public.set_members where user_id = auth.uid()
    )
  );


-- --- shopping_history ---
-- Select: Users can view their own history.
create policy "Users can view own history"
  on public.shopping_history for select
  to authenticated
  using (auth.uid() = user_id);

-- Insert: Users can insert into their own history (though mostly done via function).
create policy "Users can insert own history"
  on public.shopping_history for insert
  to authenticated
  with check (auth.uid() = user_id);

-- Delete: Users can delete their own history.
create policy "Users can delete own history"
  on public.shopping_history for delete
  to authenticated
  using (auth.uid() = user_id);



================================================
FILE: code/supabase/migrations/20260130230000_fix_list_members_rls.sql
================================================
-- 20260130230000_fix_list_members_rls.sql
-- Migration: Fix infinite recursion in list_members RLS policies
-- Description: Replaces recursive policies with simpler, non-recursive ones

-- Drop existing problematic policies
drop policy if exists "Users can view members of their lists" on public.list_members;
drop policy if exists "Members can add new members" on public.list_members;
drop policy if exists "Members can remove members" on public.list_members;

-- New SELECT policy: Users can view members of lists they created or are members of
-- This checks the lists table directly instead of recursively checking list_members
create policy "Users can view members of their lists"
  on public.list_members for select
  to authenticated
  using (
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
    or
    -- User is a member of the list (direct check, no subquery on list_members)
    user_id = auth.uid()
  );

-- New INSERT policy: Only list creators or existing members can add new members
-- Uses the lists table to check ownership, avoiding recursion
create policy "Members can add new members"
  on public.list_members for insert
  to authenticated
  with check (
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
    or
    -- User is already a member (this is safe because it's checking the row being inserted)
    exists (
      select 1 from public.list_members 
      where list_id = list_members.list_id 
      and user_id = auth.uid()
    )
  );

-- New DELETE policy: Users can remove themselves or list creators can remove anyone
create policy "Members can remove members"
  on public.list_members for delete
  to authenticated
  using (
    -- User is removing themselves
    user_id = auth.uid()
    or
    -- User is the creator of the list
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
  );

-- Note: The handle_new_user() function should work now because:
-- 1. It creates the list first (user is created_by)
-- 2. Then it inserts into list_members
-- 3. The INSERT policy checks if user is the creator (which they are)



================================================
FILE: code/supabase/migrations/20260130231500_fix_lists_rls.sql
================================================
-- 20260130231500_fix_lists_rls.sql
-- Migration: Fix infinite recursion in lists RLS policies
-- Description: Breaks circular dependency between lists and list_members policies

-- The problem: lists policies check list_members, and list_members policies check lists
-- Solution: Make lists policies self-contained using created_by field

-- Drop existing lists policies
drop policy if exists "Users can view their lists" on public.lists;
drop policy if exists "Users can update their lists" on public.lists;
drop policy if exists "Users can delete their lists" on public.lists;
drop policy if exists "Users can create lists" on public.lists;

-- New SELECT policy: Users can view lists they created
-- Note: Viewing shared lists will be handled through a separate query or view
create policy "Users can view their lists"
  on public.lists for select
  to authenticated
  using (
    -- User is the creator of the list
    created_by = auth.uid()
  );

-- New UPDATE policy: Only creators can update list metadata
create policy "Users can update their lists"
  on public.lists for update
  to authenticated
  using (
    created_by = auth.uid()
  );

-- New DELETE policy: Only creators can delete lists
create policy "Users can delete their lists"
  on public.lists for delete
  to authenticated
  using (
    created_by = auth.uid()
  );

-- INSERT policy: Authenticated users can create lists (unchanged, already safe)
create policy "Users can create lists"
  on public.lists for insert
  to authenticated
  with check (auth.uid() = created_by);

-- ============================================================================
-- IMPORTANT NOTE ABOUT SHARED LISTS
-- ============================================================================
-- With these policies, users can only see lists they created, not lists shared
-- with them. This is intentional to break the circular dependency.
--
-- To handle shared lists in your application, you have two options:
--
-- Option 1: Query list_members first, then fetch lists (RECOMMENDED)
-- -----------------------------------------------------------------------
-- In your frontend code:
--   1. Query list_members to get list_ids user has access to
--   2. Then query lists with those specific IDs
--
-- Option 2: Create a database view or function (FUTURE ENHANCEMENT)
-- -----------------------------------------------------------------------
-- Create a view that joins lists and list_members:
--   CREATE VIEW user_accessible_lists AS
--   SELECT l.* FROM lists l
--   INNER JOIN list_members lm ON l.id = lm.list_id
--   WHERE lm.user_id = auth.uid();
--
-- Then query the view instead of the table directly.
-- ============================================================================



================================================
FILE: code/supabase/migrations/20260130232000_fix_list_members_insert_recursion.sql
================================================
-- 20260130232000_fix_list_members_insert_recursion.sql
-- Migration: Fix infinite recursion in list_members INSERT policy
-- Description: Remove recursive check from INSERT policy - only list creators can add members

-- Drop the problematic INSERT policy
drop policy if exists "Members can add new members" on public.list_members;

-- New INSERT policy: Only list creators can add new members
-- This completely avoids checking list_members table, preventing recursion
create policy "Members can add new members"
  on public.list_members for insert
  to authenticated
  with check (
    -- Only the creator of the list can add members
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
  );

-- Note: This is more restrictive than before (only creators can add members, not all members)
-- but it's necessary to break the infinite recursion.
-- If you need members to invite other members in the future, you'll need to:
-- 1. Create a database function that uses SECURITY DEFINER to bypass RLS
-- 2. Have that function check membership and then insert
-- 3. Call that function from your application instead of direct INSERT



================================================
FILE: code/supabase/migrations/20260130233000_add_invite_member_function.sql
================================================
-- 20260130233000_add_invite_member_function.sql
-- Migration: Add function for members to invite other members
-- Description: Creates a SECURITY DEFINER function that allows existing members to add new members

-- Function: invite_member_to_list
-- Purpose: Allows list creators and existing members to add new members
-- This function bypasses RLS to avoid infinite recursion
create or replace function public.invite_member_to_list(
  p_list_id uuid,
  p_user_id uuid
)
returns void
security definer  -- This makes the function run with elevated privileges
set search_path = public  -- Security: prevent search_path attacks
as $$
declare
  v_caller_id uuid;
  v_is_creator boolean;
  v_is_member boolean;
begin
  -- Get the ID of the user calling this function
  v_caller_id := auth.uid();
  
  -- Security check: must be authenticated
  if v_caller_id is null then
    raise exception 'Not authenticated';
  end if;
  
  -- Check if caller is the creator of the list
  select exists(
    select 1 from public.lists 
    where id = p_list_id and created_by = v_caller_id
  ) into v_is_creator;
  
  -- Check if caller is already a member of the list
  -- This is safe here because we're in a SECURITY DEFINER function
  -- and not in an RLS policy (no recursion)
  select exists(
    select 1 from public.list_members 
    where list_id = p_list_id and user_id = v_caller_id
  ) into v_is_member;
  
  -- Authorization: caller must be creator OR existing member
  if not (v_is_creator or v_is_member) then
    raise exception 'Access denied: you must be a member of this list to invite others';
  end if;
  
  -- Validation: check if the user being invited exists
  if not exists(select 1 from public.profiles where id = p_user_id) then
    raise exception 'User does not exist';
  end if;
  
  -- Validation: check if user is already a member
  if exists(select 1 from public.list_members where list_id = p_list_id and user_id = p_user_id) then
    raise exception 'User is already a member of this list';
  end if;
  
  -- All checks passed: add the new member
  -- This INSERT bypasses RLS because of SECURITY DEFINER
  insert into public.list_members (list_id, user_id)
  values (p_list_id, p_user_id);
  
end;
$$ language plpgsql;

-- Grant execute permission to authenticated users
grant execute on function public.invite_member_to_list(uuid, uuid) to authenticated;

-- Add comment for documentation
comment on function public.invite_member_to_list is 
  'Allows list creators and existing members to invite new members to a list. Bypasses RLS to avoid infinite recursion.';



================================================
FILE: code/supabase/migrations/20260131000000_fix_set_members_rls_and_invite.sql
================================================
-- 20260131000000_fix_set_members_rls_and_invite.sql
-- Migration: Fix infinite recursion in set_members RLS and add creator to set after create
-- Description: Same pattern as list_members - non-recursive policies + SECURITY DEFINER function

-- Drop existing recursive policies on set_members
drop policy if exists "Users can view members of their sets" on public.set_members;
drop policy if exists "Members can add new set members" on public.set_members;
drop policy if exists "Members can remove set members" on public.set_members;

-- New SELECT policy: No recursion - check sets.created_by or row's user_id
create policy "Users can view members of their sets"
  on public.set_members for select
  to authenticated
  using (
    -- User is the creator of the set
    set_id in (
      select id from public.sets where created_by = auth.uid()
    )
    or
    -- User is the member in this row
    user_id = auth.uid()
  );

-- New INSERT policy: Only set creator can add members (avoids recursion - no subquery on set_members)
create policy "Members can add new set members"
  on public.set_members for insert
  to authenticated
  with check (
    set_id in (
      select id from public.sets where created_by = auth.uid()
    )
  );

-- New DELETE policy: Creator or removing self
create policy "Members can remove set members"
  on public.set_members for delete
  to authenticated
  using (
    user_id = auth.uid()
    or
    set_id in (
      select id from public.sets where created_by = auth.uid()
    )
  );

-- Function: invite_member_to_set
-- Purpose: Allows set creators and existing members to add new members (e.g. creator after createSet)
-- Bypasses RLS to avoid recursion when adding the first member
create or replace function public.invite_member_to_set(
  p_set_id uuid,
  p_user_id uuid
)
returns void
security definer
set search_path = public
as $$
declare
  v_caller_id uuid;
  v_is_creator boolean;
  v_is_member boolean;
begin
  v_caller_id := auth.uid();

  if v_caller_id is null then
    raise exception 'Not authenticated';
  end if;

  select exists(
    select 1 from public.sets
    where id = p_set_id and created_by = v_caller_id
  ) into v_is_creator;

  select exists(
    select 1 from public.set_members
    where set_id = p_set_id and user_id = v_caller_id
  ) into v_is_member;

  if not (v_is_creator or v_is_member) then
    raise exception 'Access denied: you must be a member of this set to invite others';
  end if;

  if not exists(select 1 from public.profiles where id = p_user_id) then
    raise exception 'User does not exist';
  end if;

  if exists(select 1 from public.set_members where set_id = p_set_id and user_id = p_user_id) then
    raise exception 'User is already a member of this set';
  end if;

  insert into public.set_members (set_id, user_id)
  values (p_set_id, p_user_id);
end;
$$ language plpgsql;

grant execute on function public.invite_member_to_set(uuid, uuid) to authenticated;

comment on function public.invite_member_to_set is
  'Allows set creators and existing members to add new members. Bypasses RLS to avoid infinite recursion.';



================================================
FILE: code/supabase/migrations/20260131000001_fix_sets_rls.sql
================================================
-- 20260131000001_fix_sets_rls.sql
-- Migration: Fix infinite recursion in sets RLS policies
-- Description: Same as fix_lists_rls - break circular dependency between sets and set_members
-- Sets policies must not query set_members; app will query set_members first, then sets by ID.

-- Drop existing sets policies that query set_members (causing recursion)
drop policy if exists "Users can view their sets" on public.sets;
drop policy if exists "Users can update their sets" on public.sets;
drop policy if exists "Users can delete their sets" on public.sets;
drop policy if exists "Users can create sets" on public.sets;

-- New SELECT policy: Users can view sets they created (self-contained, no set_members)
create policy "Users can view their sets"
  on public.sets for select
  to authenticated
  using (created_by = auth.uid());

-- New UPDATE policy
create policy "Users can update their sets"
  on public.sets for update
  to authenticated
  using (created_by = auth.uid());

-- New DELETE policy
create policy "Users can delete their sets"
  on public.sets for delete
  to authenticated
  using (created_by = auth.uid());

-- INSERT policy: unchanged
create policy "Users can create sets"
  on public.sets for insert
  to authenticated
  with check (auth.uid() = created_by);

-- NOTE: With these policies, users can only SELECT sets they created directly.
-- Shared sets (where user is in set_members but not created_by) require the app
-- to query set_members first for set_ids, then fetch sets with .in("id", setIds)
-- (same pattern as lists.service getAllLists).



================================================
FILE: .ai/auth-implementation-summary.md
================================================
# Podsumowanie Implementacji Widoku Uwierzytelniania

## Zrealizowane Komponenty

### 1. Typy (`src/types/auth.types.ts`)
- `AuthMode`: Typ określający tryb formularza ('signin' | 'signup')
- `AuthCredentials`: Interfejs dla danych logowania (email, pass)
- `AuthError`: Interfejs dla błędów uwierzytelniania

### 2. Komponenty UI

#### `AuthModeSwitch` (`src/components/auth/AuthModeSwitch.tsx`)
- Przełącznik między trybem logowania a rejestracją
- Wykorzystuje komponent `Tabs` z shadcn/ui
- Props: `currentMode`, `onModeChange`

#### `EmailAuthForm` (`src/components/auth/EmailAuthForm.tsx`)
- Formularz logowania/rejestracji przez email i hasło
- Walidacja z użyciem react-hook-form + zod
- Walidacja:
  - Email: format email, pole wymagane
  - Hasło: minimum 6 znaków, pole wymagane
- Wyświetla błędy walidacji pod polami
- Props: `mode`, `onSubmit`, `isLoading`

#### `GoogleAuthButton` (`src/components/auth/GoogleAuthButton.tsx`)
- Przycisk logowania przez Google OAuth
- Zawiera ikonę Google
- Pokazuje spinner podczas ładowania
- Props: `onClick`, `isLoading`

### 3. Routing

#### `/auth` (`src/routes/auth.tsx`)
- Główny widok uwierzytelniania
- Funkcjonalności:
  - Sprawdzanie sesji przy załadowaniu (przekierowanie jeśli zalogowany)
  - Logowanie przez email/hasło
  - Rejestracja przez email/hasło
  - Logowanie przez Google OAuth
  - Obsługa błędów z mapowaniem na przyjazne komunikaty
  - Obsługa potwierdzenia emaila przy rejestracji
  - Przekierowanie na `/lists` po udanym logowaniu

#### `/lists` (`src/routes/lists.tsx`)
- Placeholder dla widoku list zakupów
- Sprawdza autoryzację i przekierowuje na `/auth` jeśli niezalogowany

#### `/` (`src/routes/index.tsx`)
- Strona główna z logiką przekierowania
- Sprawdza sesję i przekierowuje:
  - Zalogowani → `/lists`
  - Niezalogowani → `/auth`

### 4. Aktualizacje Istniejących Komponentów

#### `Header` (`src/components/Header.tsx`)
- Dodano przycisk wylogowania
- Dodano link do "Moje Listy" (`/lists`)
- Zaktualizowano branding na "QuickShop"
- Funkcja `handleLogout` wywołuje `supabase.auth.signOut()`

#### `__root.tsx` (`src/routes/__root.tsx`)
- Warunkowe wyświetlanie Header
- Header ukryty na stronach `/auth` i `/` (loading)

## Zainstalowane Pakiety

```bash
npm install react-hook-form @hookform/resolvers
```

## Dodane Komponenty shadcn/ui

```bash
npx shadcn@latest add button
npx shadcn@latest add input
npx shadcn@latest add label
npx shadcn@latest add separator
```

## Integracja z Supabase

Widok wykorzystuje `supabaseClient` z `@/db/supabase.client.ts`:

1. **Logowanie Email**: `supabase.auth.signInWithPassword({ email, password })`
2. **Rejestracja Email**: `supabase.auth.signUp({ email, password })`
3. **Logowanie Google**: `supabase.auth.signInWithOAuth({ provider: 'google' })`
4. **Sprawdzanie Sesji**: `supabase.auth.getSession()`
5. **Wylogowanie**: `supabase.auth.signOut()`

## Obsługa Błędów

Mapowanie kodów błędów Supabase na przyjazne komunikaty:
- `invalid_credentials` → "Nieprawidłowy email lub hasło"
- `user_already_exists` → "Użytkownik z tym adresem email już istnieje"
- `invalid_login_credentials` → "Nieprawidłowy email lub hasło"

## Responsywność

- Widok auth wykorzystuje Mobile First approach
- Centrowany layout z `Card` o maksymalnej szerokości `max-w-md`
- Gradient tło z `bg-gradient-to-br`
- Pełna responsywność dzięki Tailwind CSS

## Testowanie

1. Uruchom serwer deweloperski: `npm run dev`
2. Otwórz `http://localhost:3000`
3. Zostaniesz przekierowany na `/auth`
4. Przetestuj:
   - Przełączanie między logowaniem a rejestracją
   - Walidację formularza (puste pola, zły format email, za krótkie hasło)
   - Logowanie przez email (wymaga konfiguracji Supabase)
   - Rejestrację przez email (wymaga konfiguracji Supabase)
   - Logowanie przez Google (wymaga konfiguracji OAuth w Supabase)

## Wymagania Konfiguracyjne

### Zmienne Środowiskowe
Utwórz plik `.env.local` na podstawie `.env.local.template`:

```env
VITE_SUPABASE_URL=<twój_supabase_url>
VITE_SUPABASE_PUBLISHABLE_KEY=<twój_supabase_anon_key>
```

### Konfiguracja Supabase

1. **Email Authentication**: Domyślnie włączone w Supabase
2. **Google OAuth**: 
   - Skonfiguruj w Supabase Dashboard → Authentication → Providers
   - Dodaj Google Client ID i Secret
   - Skonfiguruj Redirect URLs

## Następne Kroki

1. Implementacja widoku list zakupów (`/lists`)
2. Dodanie funkcjonalności resetowania hasła
3. Dodanie profilowania użytkownika
4. Implementacja persistentnej sesji
5. Dodanie testów jednostkowych i E2E

## Status

✅ Implementacja zakończona zgodnie z planem
✅ TypeScript bez błędów
✅ Linter bez błędów
✅ Serwer deweloperski działa
✅ Routing skonfigurowany i działa



================================================
FILE: .ai/auth-view-view-implementation-plan.md
================================================
# Plan implementacji widoku Uwierzytelniania

## 1. Przegląd
Widok uwierzytelniania jest punktem wejścia dla użytkowników nieautoryzowanych. Jego celem jest umożliwienie dostępu do aplikacji poprzez logowanie (email/hasło lub Google) oraz rejestrację nowych kont. Zgodnie z zasadą Mobile First, widok musi być responsywny i czytelny na małych ekranach.

## 2. Routing widoku
*   **Ścieżka**: `/auth`
*   **Dostęp**: Publiczny (dla niezalogowanych). Zalogowani użytkownicy wchodzący na tę ścieżkę powinni być przekierowywani na `/lists` (lub `/`).

## 3. Struktura komponentów
Hierarchia komponentów dla widoku `/auth`:

*   `AuthView` (Page Component)
    *   `AuthLayout` (Wrapper - centrowanie, tło, logo)
        *   `Logo`
        *   `AuthFormContainer`
            *   `AuthModeSwitch` (Przełącznik Logowanie / Rejestracja)
            *   `EmailAuthForm`
                *   `FormField` (Email)
                *   `FormField` (Hasło)
                *   `SubmitButton`
            *   `Divider` ("lub")
            *   `GoogleAuthButton`
    *   `ErrorToast` (Globalny lub lokalny komponent powiadomień o błędach)

## 4. Szczegóły komponentów

### `AuthView`
*   **Opis**: Główny kontener widoku. Zarządza stanem przekierowania po udanym logowaniu.
*   **Główne elementy**: `<div className="min-h-screen ...">`
*   **Obsługiwane interakcje**: Sprawdzenie sesji przy załadowaniu (przekierowanie jeśli już zalogowany).
*   **Obsługiwana walidacja**: Brak.
*   **Typy**: Brak specyficznych.
*   **Propsy**: Brak.

### `AuthModeSwitch`
*   **Opis**: Komponent UI do przełączania między trybem "Logowanie" a "Rejestracja".
*   **Główne elementy**: Dwa przyciski (Tab) lub Segmented Control.
*   **Obsługiwane interakcje**: Kliknięcie zmienia stan `mode` w komponencie nadrzędnym.
*   **Typy**: `AuthMode = 'signin' | 'signup'`
*   **Propsy**:
    *   `currentMode: AuthMode`
    *   `onModeChange: (mode: AuthMode) => void`

### `EmailAuthForm`
*   **Opis**: Formularz obsługujący logowanie i rejestrację przez email/hasło.
*   **Główne elementy**: `<form>`, `<input type="email">`, `<input type="password">`, `<button type="submit">`.
*   **Obsługiwane interakcje**:
    *   Wpisanie emaila i hasła.
    *   Submit formularza.
*   **Obsługiwana walidacja**:
    *   **Email**: Wymagany, poprawny format.
    *   **Hasło**: Wymagane, min. 6 znaków (wymóg Supabase).
*   **Typy**: `AuthCredentials` (patrz sekcja Typy).
*   **Propsy**:
    *   `mode: AuthMode`
    *   `onSubmit: (credentials: AuthCredentials) => Promise<void>`
    *   `isLoading: boolean`

### `GoogleAuthButton`
*   **Opis**: Przycisk inicjujący logowanie przez dostawcę OAuth (Google).
*   **Główne elementy**: `<button>`, Ikona Google.
*   **Obsługiwane interakcje**: Kliknięcie wywołuje `signInWithOAuth`.
*   **Propsy**:
    *   `onClick: () => Promise<void>`
    *   `isLoading: boolean`

## 5. Typy

```typescript
// Typy pomocnicze dla widoku Auth

export type AuthMode = 'signin' | 'signup';

export interface AuthCredentials {
  email: string;
  pass: string; // "pass" zamiast "password" by uniknąć kolizji z atrybutami HTML
}

export interface AuthError {
  message: string;
  code?: string;
}
```

## 6. Zarządzanie stanem

Stan będzie zarządzany lokalnie w komponencie `AuthView` (lub wydzielonym hooku `useAuthLogic`), ponieważ jest to logika specyficzna dla tego widoku.

*   `mode`: `AuthMode` - określa czy wyświetlamy formularz logowania czy rejestracji.
*   `isLoading`: `boolean` - blokuje interfejs podczas komunikacji z API.
*   `error`: `string | null` - przechowuje treść błędu do wyświetlenia.
*   `formData`: (zarządzane przez React Hook Form lub stan lokalny w `EmailAuthForm`).

**Custom Hook: `useAuthForm`** (opcjonalnie, wewnątrz `EmailAuthForm`) do obsługi walidacji i submitu.

## 7. Integracja z interfejsami

Widok korzysta bezpośrednio z `supabaseClient` (zdefiniowanego w `@src/db/supabase.client.ts`).

1.  **Logowanie Email**:
    *   Metoda: `supabase.auth.signInWithPassword({ email, password })`
    *   Parametry: `{ email: string, password: string }`
    *   Wynik: `{ data: { user, session }, error }`
    *   Obsługa błędu: Wyświetlenie `error.message`.

2.  **Rejestracja Email**:
    *   Metoda: `supabase.auth.signUp({ email, password })`
    *   Parametry: `{ email: string, password: string }`
    *   Wynik: `{ data: { user, session }, error }`
    *   **Uwaga**: Supabase może wymagać potwierdzenia emaila. Należy sprawdzić konfigurację lub obsłużyć komunikat "Sprawdź skrzynkę pocztową". W MVP zakładamy auto-login lub jasny komunikat.

3.  **Logowanie Google**:
    *   Metoda: `supabase.auth.signInWithOAuth({ provider: 'google' })`
    *   Parametry: `{ provider: 'google', options: { redirectTo: ... } }`
    *   Wynik: Przekierowanie przeglądarki.

## 8. Interakcje użytkownika

1.  **Przełączanie trybu**: Użytkownik klika "Zarejestruj się" -> nagłówek formularza i przycisk akcji zmieniają tekst ("Zarejestruj", "Załóż konto").
2.  **Wypełnianie formularza**: Walidacja "onBlur" lub przy próbie wysłania. Błędy walidacji (np. "Niepoprawny email") pojawiają się pod polami.
3.  **Wysłanie formularza (Sukces)**:
    *   Spinner na przycisku.
    *   Zablokowanie inputów.
    *   Po sukcesie: Przekierowanie na `/lists` (React Router `navigate`).
4.  **Wysłanie formularza (Błąd)**:
    *   Spinner znika.
    *   Formularz odblokowany.
    *   Toast/Alert z komunikatem błędu (np. "Błędne hasło").
5.  **Logowanie Google**:
    *   Kliknięcie -> Przekierowanie do Google -> Powrót do aplikacji (automatycznie obsłużone przez sesję Supabase).

## 9. Warunki i walidacja

*   **Email**: Regex dla formatu email, pole wymagane.
*   **Hasło**: Pole wymagane, minimum 6 znaków (ograniczenie Supabase).
*   **Stan ładowania**: Podczas `isLoading === true` wszystkie przyciski i inputy muszą mieć atrybut `disabled`.

## 10. Obsługa błędów

*   **Błędy API (Supabase)**: Przechwytywanie obiektu `error` z odpowiedzi `signIn`/`signUp`. Mapowanie kodów błędów na przyjazne komunikaty (np. "invalid_login_credentials" -> "Nieprawidłowy email lub hasło").
*   **Błędy Sieci**: Standardowa obsługa błędów klienta Supabase.
*   **Błędy Walidacji**: Obsługiwane przez formularz przed wysłaniem żądania.

## 11. Kroki implementacji

1.  Stworzenie struktury katalogów: `src/routes/auth.tsx` (dla TanStack Router) lub odpowiednio dla używanego routera.
2.  Implementacja komponentów UI: `AuthLayout`, `AuthModeSwitch`, `GoogleAuthButton`.
3.  Implementacja formularza `EmailAuthForm` z walidacją (np. używając React Hook Form i Zod, jeśli są w stacku, lub czystego Reacta).
4.  Integracja z `supabase.auth` w głównym komponencie widoku (`AuthView` lub `src/routes/auth.tsx`).
5.  Obsługa stanów `loading` i `error`.
6.  Dodanie przekierowania po udanym zalogowaniu (`navigate('/lists')`).
7.  Podpięcie routingu (jeśli nie jest automatyczne w `src/routes`).
8.  Weryfikacja działania logowania Google i Email.



================================================
FILE: .ai/business-logic-plan.md
================================================
<api_analysis>

1.  **Database Entity Analysis**

    *   **Profiles (`profiles`)**: User identity.
        *   *Columns*: `id`, `full_name`, `email`.
        *   *Relevance*: Used for `list_members` and `set_members`.
    *   **Lists (`lists`)**: The central grouping entity.
        *   *Columns*: `id`, `name`, `created_by`.
        *   *Relevance*: Parent of items, subject of sharing.
    *   **List Members (`list_members`)**: Permissions/Sharing.
        *   *Columns*: `list_id`, `user_id`.
        *   *Relevance*: Determines access control (RLS).
    *   **List Items (`list_items`)**: The actual content.
        *   *Columns*: `id`, `list_id`, `name`, `quantity`, `note`, `is_bought`, `sort_order`.
        *   *Relevance*: High frequency CRUD, sorting, toggling status.
    *   **Sets (`sets`)**: Templates.
        *   *Columns*: `id`, `name`, `description`.
    *   **Set Items (`set_items`)**: Template content.
        *   *Columns*: `set_id`, `name`, `quantity`, `sort_order`.
    *   **Shopping History (`shopping_history`)**: Archive.
        *   *Columns*: `user_id`, `list_name`, `items_snapshot`, `completed_at`.
        *   *Relevance*: Created via RPC `archive_list_items`.

2.  **PRD Business Logic Mapping**

    *   **Auth (US-001 - US-003)**: Handled primarily by Supabase Auth SDK. We need a helper to get the current user profile.
    *   **Lists (US-004 - US-006)**:
        *   Create: Simple insert.
        *   Share: Insert into `list_members`. Requires looking up user ID by email.
        *   Archive: Triggers `archive_list_items` RPC and potentially updates list status or deletes it (PRD implies "list disappears from active", DB plan mentions `archive_list_items` function).
    *   **Items (US-007 - US-011)**:
        *   Add/Update/Delete: Standard CRUD.
        *   Reorder: Batch update of `sort_order`.
        *   Duplicates: PRD requires UI logic ("highlight existing"). Service needs `updateListItem` (to merge quantities) and `createListItem` (if new).
    *   **Sets (US-012 - US-014)**:
        *   Create from List: Needs to read list items and insert into set/set_items.
        *   Add to List: Needs to read set items and insert/merge into list_items.
    *   **History (US-015)**: Read-only access to `shopping_history`.

3.  **Interface Design Decisions**

    *   *Granularity*: Should we have a giant `QuickShopService` or split it?
        *   *Decision*: Split into logical domains: `ListService`, `SetService`, `HistoryService`, `ProfileService`. This keeps code maintainable.
    *   *Method: `shareList`*:
        *   Option A: `shareList(listId, userId)` - assumes we already know the UUID.
        *   Option B: `shareList(listId, email)` - handles the lookup internally.
        *   *Decision*: Option B is more aligned with the UI flow (User enters email), but purely DB-centric interfaces usually expect IDs. I will propose `inviteUserByEmail(listId, email)` which encapsulates the lookup logic.
    *   *Method: `completeShopping` (US-006)*:
        *   The DB Plan specifies a specific RPC function `archive_list_items`. The interface *must* expose this.
    *   *Method: `addSetToList` (US-014)*:
        *   PRD mentions "Ask user to increase quantity" if duplicate. This implies the merging logic happens *client-side* (or in the business layer before DB commit).
        *   The interface needs to support `bulkUpsertListItems` or the client will loop `create/update`. A `bulkCreate` is more efficient for adding a whole set.

4.  **Validation & Types**:
    *   We will rely on generated Supabase types for entities but create stricter DTOs for creation/updates (removing system fields like `created_at`).

</api_analysis>

# Business Logic Interface Proposal

This document outlines the TypeScript interfaces for the application's business logic layer. These interfaces are designed to be implemented using Supabase client + TanStack Query.

## 1. Type Definitions

These types mirror the database schema but are adapted for frontend usage. We assume the existence of a base `Database` type generated from Supabase.

```typescript
import { Database } from '../db/database.types';

// Primitive Types aliases for clarity
type UUID = string;

// Domain Entities
export type Profile = Database['public']['Tables']['profiles']['Row'];
export type ShoppingList = Database['public']['Tables']['lists']['Row'];
export type ListItem = Database['public']['Tables']['list_items']['Row'];
export type ShoppingSet = Database['public']['Tables']['sets']['Row'];
export type SetItem = Database['public']['Tables']['set_items']['Row'];
export type HistoryEntry = Database['public']['Tables']['shopping_history']['Row'];

// DTOs (Data Transfer Objects) for creating/updating
export interface CreateListDTO {
  name: string;
}

export interface CreateListItemDTO {
  list_id: UUID;
  name: string;
  quantity?: string | null;
  note?: string | null;
  is_bought?: boolean;
  sort_order?: number;
}

export interface UpdateListItemDTO {
  id: UUID;
  name?: string;
  quantity?: string | null;
  note?: string | null;
  is_bought?: boolean;
  sort_order?: number;
}

export interface CreateSetDTO {
  name: string;
  description?: string | null;
}

export interface CreateSetItemDTO {
  set_id: UUID;
  name: string;
  quantity?: string | null;
  note?: string | null;
  sort_order?: number;
}
```

## 2. Service Interfaces

### I. List Service (`ListsService`)
Handles lifecycle of shopping lists and their items.

```typescript
export interface IListService {
  /**
   * Fetches all lists the current user has access to (own + shared).
   * Maps to: select * from lists (RLS handles filtering)
   */
  getAllLists(): Promise<ShoppingList[]>;

  /**
   * Fetches a single list details.
   */
  getListById(listId: UUID): Promise<ShoppingList>;

  /**
   * Creates a new shopping list.
   * US-004
   */
  createList(data: CreateListDTO): Promise<ShoppingList>;

  /**
   * Updates list metadata (e.g. name).
   */
  updateList(listId: UUID, data: Partial<CreateListDTO>): Promise<ShoppingList>;

  /**
   * Deletes a list permanently.
   */
  deleteList(listId: UUID): Promise<void>;

  /**
   * Shares a list with another user by email.
   * Implementation: Look up profile by email -> Insert into list_members.
   * MVP Constraint: Throws error if email does not exist in `profiles` (no invitations).
   * US-005
   */
  shareListWithEmail(listId: UUID, email: string): Promise<void>;

  /**
   * Completes the shopping trip.
   * Implementation: Calls RPC `archive_list_items(list_id)`.
   * Note: The List entity REMAINS in the database (now empty) and is not deleted.
   * US-006
   */
  completeShoppingTrip(listId: UUID): Promise<void>;
}
```

### II. List Item Service (`ListItemsService`)
Handles manipulation of specific items within a list.

```typescript
export interface IListItemsService {
  /**
   * Fetches all items for a specific list.
   * Should support sorting by `sort_order` or `is_bought`.
   */
  getItemsByListId(listId: UUID): Promise<ListItem[]>;

  /**
   * Adds a single item to a list.
   * US-007
   */
  createItem(data: CreateListItemDTO): Promise<ListItem>;

  /**
   * Updates an item (toggle bought, change quantity, edit note).
   * US-009, US-010. Note: Merging duplicates uses String Concatenation for quantity (e.g. "1"+"2" -> "1+2"), not math.
   */
  updateItem(data: UpdateListItemDTO): Promise<ListItem>;

  /**
   * Deletes an item.
   */
  deleteItem(itemId: UUID): Promise<void>;

  /**
   * Updates the order of multiple items.
   * Implementation: Bulk update of `sort_order` field.
   * Note: `sort_order` values are preserved regardless of `is_bought` status.
   * US-011
   */
  reorderItems(items: { id: UUID; sort_order: number }[]): Promise<void>;
  
  /**
   * Bulk creates items (used when importing from Sets).
   * US-014
   */
  bulkCreateItems(items: CreateListItemDTO[]): Promise<ListItem[]>;
}
```

### III. Set Service (`SetsService`)
Handles Templates/Sets.

```typescript
export interface ISetsService {
  /**
   * Fetches all sets available to the user.
   */
  getAllSets(): Promise<ShoppingSet[]>;

  /**
   * Fetches items belonging to a specific set.
   */
  getSetItems(setId: UUID): Promise<SetItem[]>;

  /**
   * Creates a new empty set.
   * US-013
   */
  createSet(data: CreateSetDTO): Promise<ShoppingSet>;

  /**
   * Creates a new set populated with items from an existing list.
   * Implementation: Fetch list items -> Create Set -> Bulk Create Set Items.
   * US-012
   */
  createSetFromList(listId: UUID, data: CreateSetDTO): Promise<ShoppingSet>;

  /**
   * Add items to a set.
   */
  addSetItem(data: CreateSetItemDTO): Promise<SetItem>;
  
  /**
   * Updates a set item.
   */
  updateSetItem(itemId: UUID, data: Partial<CreateSetItemDTO>): Promise<SetItem>;

  /**
   * Deletes a set item.
   */
  deleteSetItem(itemId: UUID): Promise<void>;
  
   /**
   * Deletes a set.
   */
  deleteSet(setId: UUID): Promise<void>;
}
```

### IV. History Service (`HistoryService`)

```typescript
export interface IHistoryService {
  /**
   * Fetches completed shopping trips.
   * US-015
   */
  getHistory(): Promise<HistoryEntry[]>;
}
```

## 3. User Story Mapping

| User Story | Method / Action | Logic Details |
| :--- | :--- | :--- |
| **US-001 - US-003** (Auth) | *Supabase Auth SDK* | Handled directly by `supabase.auth.signIn*` |
| **US-004** (Create List) | `ListsService.createList` | Inserts row into `lists`. |
| **US-005** (Share List) | `ListsService.shareListWithEmail` | Needs to handle "User not found" errors gracefully. |
| **US-006** (Archive) | `ListsService.completeShoppingTrip` | Triggers DB function `archive_list_items`. |
| **US-007** (Add Item) | `ListItemsService.createItem` | Standard INSERT. |
| **US-008** (Offline Add) | *TanStack Query Mutation* | `createItem` will be used with `onMutate` for optimistic update. |
| **US-009** (Toggle Bought) | `ListItemsService.updateItem` | Update `is_bought = true`. |
| **US-010** (Duplicates) | `ListItemsService.updateItem` | UI detects duplicate name -> prompts user -> calls `updateItem` to sum quantity instead of `createItem`. |
| **US-011** (Sort) | `ListItemsService.reorderItems` | Updates `sort_order` float values. |
| **US-012** (Set from List) | `SetsService.createSetFromList` | Reads List Items -> Writes Set Items. |
| **US-013** (Manage Sets) | `SetsService` (various) | CRUD on Sets and SetItems tables. |
| **US-014** (Set to List) | `ListItemsService.bulkCreateItems` | UI fetches Set Items -> transforms to `CreateListItemDTO` -> calls bulk create. |
| **US-015** (History) | `HistoryService.getHistory` | Simple SELECT with ordering. |

## 4. Implementation Notes

1.  **Optimistic UI (US-008, US-016)**:
    *   All "Create/Update/Delete" methods in the implementation should be wrapped in TanStack Query `useMutation` hooks.
    *   The `onMutate` callback must strictly update the cache to ensure the app feels instant (offline-first).
    *   Since `id`s are UUIDs generated by the DB (`default: gen_random_uuid()`), for optimistic creation, we must generate a temporary UUID on the client side to track the item in the cache until the server confirms the real ID.

2.  **Conflict Resolution (US-017, US-018)**:
    *   Supabase Realtime subscriptions should be set up in a `useEffect` at the List View level.
    *   When an `INSERT/UPDATE/DELETE` event arrives via WebSocket, the TanStack Query cache should be invalidated or updated directly.
    *   "Last Write Wins" is the default behavior of PostgreSQL `UPDATE`, so no special logic is needed in the interface unless we want to merge JSON blobs (which we aren't doing for items).

3.  **Authentication**:
    *   The Supabase client used in these services must be the authenticated instance.
    *   `shareListWithEmail` requires a strategy to find `user_id` from `email`. Since `profiles` table is readable by authenticated users (per DB Plan), we can perform a `SELECT id FROM profiles WHERE email = $1`.

4.  **Bulk Operations**:
    *   `reorderItems` and `bulkCreateItems` should use `supabase.from(...).upsert(...)` or `.insert(...)` with an array of objects to minimize network requests.

5.  **Validation**:
    *   Inputs should be validated using Zod schemas before calling these services to ensure `quantity` formats or `names` meet requirements (e.g., non-empty).



================================================
FILE: .ai/database-fix-guide.md
================================================
# Database RLS Policy Fix Guide - COMPLETE FIX

## Problem Description

When trying to create a new list, you encountered these errors:

```
Error 1: infinite recursion detected in policy for relation "list_members"
Error 2: infinite recursion detected in policy for relation "lists"
Code: 42P17
```

## Root Cause

The RLS (Row Level Security) policies had **circular dependencies** between `lists` and `list_members` tables that caused infinite recursion:

1. **SELECT policy** checked: "Can user view this member row?"
   - Answer: "Only if they're in `list_members` for this list"
   - This requires querying `list_members` again → recursion!

2. **INSERT policy** checked: "Can user add a new member?"
   - Answer: "Only if they're already in `list_members` for this list"
   - This requires querying `list_members` again → recursion!

This is especially problematic when:
- Creating a new list (the creator needs to be added as the first member)
- The `handle_new_user()` trigger tries to add the user to their first list

## The Circular Dependency Problem

```
┌─────────────────────────────────────────────────────┐
│  lists.SELECT policy                                │
│  → checks list_members (is user a member?)         │
│     └→ list_members.SELECT policy                  │
│        → checks lists.created_by                   │
│           └→ lists.SELECT policy ♾️ RECURSION!    │
└─────────────────────────────────────────────────────┘
```

## Solution

**Two-part fix:**

1. **Break the cycle**: Make `lists` policies only check `created_by` (no reference to `list_members`)
2. **Update frontend code**: Query `list_members` first, then fetch lists with those IDs

### Part 1: Fix Database Policies

### Old Policy (Recursive ❌)
```sql
create policy "Members can add new members"
  on public.list_members for insert
  with check (
    list_id in (
      select list_id from public.list_members where user_id = auth.uid()
    )
  );
```

### New Policy (Non-Recursive ✅)
```sql
create policy "Members can add new members"
  on public.list_members for insert
  with check (
    -- Check if user created the list (no recursion)
    list_id in (
      select id from public.lists where created_by = auth.uid()
    )
    or
    -- Or if user is already a member
    exists (
      select 1 from public.list_members 
      where list_id = list_members.list_id 
      and user_id = auth.uid()
    )
  );
```

## How to Apply the Fix

### Option 1: Supabase CLI (Recommended - You already have it!)

```bash
cd code
npx supabase db push
```

This will apply the new migration: `20260130231500_fix_lists_rls.sql`

### Option 2: Supabase Dashboard (Alternative)

1. **Open Supabase Dashboard**
   - Go to https://supabase.com/dashboard
   - Select your project: `syjwmkiflgnxauitdrez`

2. **Navigate to SQL Editor**
   - Click on "SQL Editor" in the left sidebar
   - Click "New query"

3. **Copy and Paste the Complete Fix**
   - Open the file: `code/supabase/APPLY_FIX_COMPLETE.sql`
   - Copy the entire contents
   - Paste into the SQL Editor

4. **Run the Script**
   - Click the "Run" button (or press Ctrl+Enter)
   - Wait for confirmation message

5. **Verify**
   - You should see: "Success. No rows returned"
   - Both sets of policies have been updated

## Testing After Fix

After applying the fix, test the following:

1. **Create a New List**
   - Go to http://localhost:3000/lists
   - Click "Nowa lista"
   - Enter a name and click "Utwórz"
   - ✅ Should work without errors

2. **View Lists**
   - You should see all your lists displayed
   - ✅ No infinite recursion errors

3. **Delete a List**
   - Click the three-dot menu on a list
   - Click "Usuń listę"
   - Confirm deletion
   - ✅ Should work smoothly

4. **Create New User** (Optional)
   - Log out and create a new account
   - The `handle_new_user()` trigger should create a default list
   - ✅ No errors during signup

## Technical Details

### What Changed

#### Database Policies (Both Tables)

**list_members policies:**
- ✅ SELECT: Check `lists.created_by` OR direct user_id match (no recursion)
- ✅ INSERT: Check `lists.created_by` (no recursion)
- ✅ DELETE: Check `lists.created_by` OR self-removal (no recursion)

**lists policies:**
- ✅ SELECT: Only check `created_by = auth.uid()` (no list_members reference)
- ✅ UPDATE: Only check `created_by = auth.uid()` (no list_members reference)
- ✅ DELETE: Only check `created_by = auth.uid()` (no list_members reference)
- ✅ INSERT: Check `created_by = auth.uid()` (unchanged, already safe)

#### Frontend Code Changes

**Updated: `services/lists.service.ts`**

```typescript
async getAllLists(): Promise<ShoppingList[]> {
  // Step 1: Query list_members to get accessible list IDs
  const { data: memberData } = await supabaseClient
    .from("list_members")
    .select("list_id")
    .eq("user_id", user.id);

  // Step 2: Fetch lists using those IDs
  const { data } = await supabaseClient
    .from("lists")
    .select("*")
    .in("id", listIds);
    
  return data;
}
```

### Why This Works

1. **No Circular Dependencies**: 
   - `lists` policies never check `list_members`
   - `list_members` policies check `lists.created_by` (which doesn't trigger recursion)

2. **Two-Step Query Pattern**: 
   - Frontend queries `list_members` first (gets list IDs)
   - Then queries `lists` with specific IDs
   - This bypasses the RLS circular dependency

3. **Creator Privileges**: 
   - List creators have automatic permission via `created_by` field
   - No need to check membership for creators

4. **Shared Lists Work**: 
   - Users can see shared lists because frontend queries `list_members` first
   - RLS policies don't need to handle shared list visibility

## Files Modified

### Database Migrations
1. ✅ `code/supabase/migrations/20260130230000_fix_list_members_rls.sql` - Fixes list_members policies
2. ✅ `code/supabase/migrations/20260130231500_fix_lists_rls.sql` - Fixes lists policies
3. ✅ `code/supabase/APPLY_FIX_COMPLETE.sql` - Complete fix for manual application

### Frontend Code
4. ✅ `code/src/services/lists.service.ts` - Updated getAllLists() to use two-step query

### Documentation
5. ✅ `.ai/database-fix-guide.md` - This guide (updated)

## Next Steps

1. **Apply the fix** using one of the methods above
2. **Test list creation** in your app
3. **Verify** that all list operations work correctly
4. **Continue development** - the Lists View is now fully functional!

## Additional Notes

### Similar Issues in Other Tables

The same recursive pattern exists in:
- `set_members` policies (for sharing sets)

If you encounter similar errors with sets, the same fix pattern can be applied:
- Check `sets.created_by` instead of recursively checking `set_members`

### Future Improvements

Consider creating database functions for common permission checks:
```sql
create or replace function is_list_member(p_list_id uuid, p_user_id uuid)
returns boolean as $$
  select exists(
    select 1 from list_members 
    where list_id = p_list_id and user_id = p_user_id
  );
$$ language sql security definer;
```

This would centralize permission logic and make policies easier to maintain.

## Support

If you encounter any issues after applying the fix:
1. Check the Supabase Dashboard logs
2. Verify the policies were created correctly
3. Try refreshing your browser cache
4. Check browser console for any new errors

The fix has been tested and should resolve the infinite recursion error completely.



================================================
FILE: .ai/db-plan.md
================================================
# Schemat Bazy Danych QuickShop

## 1. Lista Tabel

### `profiles`
Tabela przechowująca publiczne informacje o użytkownikach.
*   `id`: uuid (PK, FK -> auth.users.id) - Identyfikator użytkownika
*   `full_name`: text (nullable) - Imię i nazwisko
*   `email`: text (nullable) - Adres email (kopia z auth.users dla łatwiejszego dostępu)
*   `updated_at`: timestamptz - Data ostatniej aktualizacji

### `lists`
Główne listy zakupowe.
*   `id`: uuid (PK, default: gen_random_uuid()) - Unikalny identyfikator listy
*   `name`: text (not null) - Nazwa listy
*   `created_by`: uuid (FK -> auth.users.id, not null) - Twórca listy
*   `created_at`: timestamptz (default: now()) - Data utworzenia
*   `updated_at`: timestamptz (default: now()) - Data ostatniej edycji

### `list_members`
Tabela łącząca dla współdzielenia list (relacja wiele-do-wielu).
*   `list_id`: uuid (PK, FK -> lists.id, ON DELETE CASCADE)
*   `user_id`: uuid (PK, FK -> profiles.id, ON DELETE CASCADE)
*   `created_at`: timestamptz (default: now())

### `list_items`
Pozycje na liście zakupów.
*   `id`: uuid (PK, default: gen_random_uuid())
*   `list_id`: uuid (FK -> lists.id, ON DELETE CASCADE)
*   `name`: text (not null) - Nazwa produktu
*   `quantity`: text (nullable) - Ilość (np. "2 szt", "1 kg")
*   `note`: text (nullable) - Dodatkowe uwagi
*   `is_bought`: boolean (default: false) - Status zakupu
*   `sort_order`: double precision (default: 0.0) - Kolejność (drag & drop)
*   `created_at`: timestamptz (default: now())
*   `updated_at`: timestamptz (default: now())

### `sets`
Szablony zakupowe (zestawy).
*   `id`: uuid (PK, default: gen_random_uuid())
*   `name`: text (not null) - Nazwa zestawu
*   `description`: text (nullable) - Opis zestawu
*   `created_by`: uuid (FK -> auth.users.id, not null)
*   `created_at`: timestamptz (default: now())
*   `updated_at`: timestamptz (default: now())

### `set_members`
Tabela łącząca dla współdzielenia zestawów.
*   `set_id`: uuid (PK, FK -> sets.id, ON DELETE CASCADE)
*   `user_id`: uuid (PK, FK -> profiles.id, ON DELETE CASCADE)
*   `created_at`: timestamptz (default: now())

### `set_items`
Pozycje w zestawie (szablonie).
*   `id`: uuid (PK, default: gen_random_uuid())
*   `set_id`: uuid (FK -> sets.id, ON DELETE CASCADE)
*   `name`: text (not null)
*   `quantity`: text (nullable)
*   `note`: text (nullable)
*   `sort_order`: double precision (default: 0.0)
*   `created_at`: timestamptz (default: now())
*   `updated_at`: timestamptz (default: now())

### `shopping_history`
Archiwum zakończonych zakupów.
*   `id`: uuid (PK, default: gen_random_uuid())
*   `user_id`: uuid (FK -> profiles.id, not null) - Kto zakończył zakupy
*   `list_name`: text (not null) - Nazwa listy w momencie archiwizacji
*   `items_snapshot`: jsonb (not null) - Zrzut zakupionych produktów (nazwa, ilość, notatka)
*   `completed_at`: timestamptz (default: now()) - Data zakończenia zakupów

## 2. Relacje

*   **Użytkownicy - Listy**: Relacja wiele-do-wielu przez tabelę `list_members`.
*   **Listy - Elementy Listy**: Relacja jeden-do-wielu (`lists.id` -> `list_items.list_id`).
*   **Użytkownicy - Zestawy**: Relacja wiele-do-wielu przez tabelę `set_members`.
*   **Zestawy - Elementy Zestawu**: Relacja jeden-do-wielu (`sets.id` -> `set_items.set_id`).
*   **Użytkownicy - Historia**: Relacja jeden-do-wielu (`profiles.id` -> `shopping_history.user_id`).
*   **Użytkownicy - Profile**: Relacja jeden-do-jednego (`auth.users.id` -> `profiles.id`).

## 3. Indeksy

*   `list_items`: indeks na `list_id` (częste filtrowanie po liście).
*   `list_members`: indeks na `user_id` (pobieranie list użytkownika).
*   `list_members`: indeks na `list_id` (sprawdzanie uprawnień).
*   `set_items`: indeks na `set_id`.
*   `set_members`: indeks na `user_id`.
*   `set_members`: indeks na `set_id`.
*   `shopping_history`: indeks na `user_id` (historia użytkownika).
*   `shopping_history`: indeks na `completed_at` (sortowanie historii).

## 4. Zasady PostgreSQL (RLS)

Wszystkie tabele będą miały włączone RLS (`ALTER TABLE ... ENABLE ROW LEVEL SECURITY`).

### `profiles`
*   `SELECT`: Dostępne dla każdego uwierzytelnionego użytkownika (aby móc wyszukać innych do współdzielenia).
*   `UPDATE`: Tylko dla właściciela rekordu (`auth.uid() = id`).
*   `INSERT`: Trigger systemowy (zakładany przy rejestracji).

### `lists`
*   `SELECT`, `UPDATE`, `DELETE`: Jeśli użytkownik znajduje się w `list_members` dla danej listy (`auth.uid() IN (SELECT user_id FROM list_members WHERE list_id = id)`).
*   `INSERT`: Dla każdego uwierzytelnionego użytkownika.

### `list_members`
*   `SELECT`: Jeśli użytkownik jest członkiem listy.
*   `INSERT`, `DELETE`: Jeśli użytkownik jest członkiem listy (wszyscy członkowie mogą zarządzać dostępem w MVP).

### `list_items`
*   `ALL`: Jeśli użytkownik ma dostęp do listy nadrzędnej (`list_id`). Sprawdzenie przez `list_members`.

### `sets`
*   Analogicznie do `lists` (przez `set_members`).

### `set_members`
*   Analogicznie do `list_members`.

### `set_items`
*   Analogicznie do `list_items` (przez `set_id`).

### `shopping_history`
*   `SELECT`, `INSERT`: Tylko dla właściciela rekordu (`auth.uid() = user_id`).

## 5. Dodatkowe uwagi

### Funkcje i Triggery
1.  **`handle_new_user`**: Trigger po `INSERT` na `auth.users`, który tworzy rekord w `public.profiles` oraz domyślną listę powitalną (zgodnie z PRD).
2.  **`update_updated_at`**: Trigger aktualizujący kolumnę `updated_at` przed każdą zmianą (`UPDATE`) w tabelach edytowalnych (`lists`, `list_items`, `sets`, `set_items`).
3.  **`archive_list_items(list_id uuid)`**: Funkcja RPC (Database Function).
    *   Pobiera elementy z `list_items` gdzie `list_id = $1` AND `is_bought = true`.
    *   Tworzy wpis w `shopping_history`.
    *   Usuwa pobrane elementy z `list_items`.

### Typy danych
*   `quantity` w tabelach items to `text` (zamiast liczby), aby obsłużyć różne jednostki (np. "1.5 kg", "opakowanie") bez skomplikowanej logiki jednostek w MVP.
*   `sort_order` to `double precision` (float), co pozwala na wstawianie elementów pomiędzy inne (np. `(1.0 + 2.0) / 2 = 1.5`) bez konieczności aktualizacji wszystkich indeksów.

### Bezpieczeństwo
*   Polityki RLS będą kluczowym mechanizmem zabezpieczającym dane.
*   Brak ról ("admin", "viewer") w MVP upraszcza logikę `list_members` - samo bycie w tabeli daje pełne prawa.



================================================
FILE: .ai/fix-missing-list-members.md
================================================
# Fix: Lists Not Showing Up (Missing list_members Entries)

## The Problem

You created a list and can see it in the database, but it doesn't show up on the screen. The issue is that the list creator wasn't added to the `list_members` table.

### Why This Happened

The original `createList` service method only inserted into the `lists` table but forgot to add the creator to `list_members`. Since our query pattern is:
1. Query `list_members` to get accessible list IDs
2. Query `lists` with those IDs

If the creator isn't in `list_members`, the list won't be found!

## The Solution (2 Steps)

### ✅ Step 1: Fix the Code (Already Done!)

Updated `services/lists.service.ts` → `createList()` method now:
1. Creates the list in `lists` table
2. Adds the creator to `list_members` table

**Future lists will work correctly!**

### ✅ Step 2: Fix Existing Lists in Database

Run this SQL in your Supabase Dashboard to fix the list you already created:

#### Option A: Quick Fix (Supabase Dashboard)

1. Go to https://supabase.com/dashboard
2. Open SQL Editor
3. Run this query:

```sql
-- Add missing list_members entries for list creators
insert into public.list_members (list_id, user_id)
select l.id, l.created_by
from public.lists l
where not exists (
  select 1 
  from public.list_members lm 
  where lm.list_id = l.id 
  and lm.user_id = l.created_by
)
on conflict (list_id, user_id) do nothing;
```

#### Option B: Use the Script

1. Go to Supabase SQL Editor
2. Copy contents from: `code/supabase/FIX_EXISTING_LISTS.sql`
3. Paste and run

## Test It

After running the SQL:

1. **Refresh your browser** at http://localhost:3000/lists
2. **Your list should now appear!** ✨
3. **Try creating a new list** - it should work and appear immediately

## What Changed

### Before (❌ Broken)
```typescript
async createList(data: CreateListDTO) {
  // Only insert into lists table
  const { data: newList } = await supabaseClient
    .from("lists")
    .insert({ ...data, created_by: user.id })
    .select()
    .single();
  
  return newList;
  // ❌ Creator not added to list_members!
}
```

### After (✅ Fixed)
```typescript
async createList(data: CreateListDTO) {
  // Step 1: Insert into lists table
  const { data: newList } = await supabaseClient
    .from("lists")
    .insert({ ...data, created_by: user.id })
    .select()
    .single();
  
  // Step 2: Add creator to list_members
  await supabaseClient
    .from("list_members")
    .insert({
      list_id: newList.id,
      user_id: user.id,
    });
  
  return newList;
  // ✅ Creator is now a member!
}
```

## Why This Works

The query flow is now complete:

```
1. User creates list
   ↓
2. List inserted into `lists` table
   ↓
3. Creator added to `list_members` table
   ↓
4. getAllLists() queries list_members (finds the list!)
   ↓
5. Fetches list details from `lists` table
   ↓
6. List appears on screen ✨
```

## Files Modified

1. ✅ `code/src/services/lists.service.ts` - Fixed createList method
2. ✅ `code/supabase/FIX_EXISTING_LISTS.sql` - SQL to fix existing lists
3. ✅ `.ai/fix-missing-list-members.md` - This guide

## Summary

- **Root cause**: `createList` didn't add creator to `list_members`
- **Code fix**: Updated `createList` to insert into both tables
- **Database fix**: Run SQL to add missing entries for existing lists
- **Result**: All lists now show up correctly! 🎉



================================================
FILE: .ai/full-impl-plan-04-list-details-view-implementation-plan.md
================================================
# Pełny plan wdrożenia: Widok Szczegółów Listy (List Details)

**Odniesienie:** ui-plan.md §2.3, §5.1, §5.2; impl-plan-04-list-details  
**Ścieżka:** `/lists/:listId`  
**Część:** 4 – Szczegóły listy

---

## 1. Cel i zakres

**Cel:** Wdrożenie widoku szczegółów listy zakupów umożliwiającego zarządzanie produktami na liście, realizację zakupów (oznaczanie jako kupione) oraz podstawowe akcje na liście (udostępnianie, archiwizacja, zmiana nazwy).

**Zakres:**
- Nagłówek z nazwą listy, przyciskiem Wstecz, miejscem na SyncStatusIndicator oraz menu (Udostępnij, Utwórz zestaw, Zmień nazwę, Zakończ zakupy).
- Lista aktywnych produktów (do kupienia) oraz sekcja „Kupione” z wyszarzonymi pozycjami.
- Wiersz produktu (ListItemRow): checkbox, nazwa, ilość/notatka, drag handle, menu (Usuń).
- StickyInputBar przyklejony do dołu ekranu do dodawania produktów.
- Optimistic UI: natychmiastowe odzwierciedlenie dodania/zmiany z obniżoną opacity dla niesynchronizowanych elementów.
- Wykrywanie duplikatów: przy dodaniu produktu o istniejącej nazwie – ItemConflictDialog z edycją ilości (updateItem zamiast createItem).
- Archiwizacja z potwierdzeniem i przekierowaniem na `/lists`.
- Placeholdery: ShareModal (część 8), SyncStatusIndicator (część 9), ewentualnie swipe-to-delete i long-press (część 9).

---

## 2. Wymagania (User Stories i kryteria akceptacji)

| Id   | User Story | Kryterium |
|------|------------|-----------|
| US-007 | Dodawanie produktu | Pole tekstowe; opcjonalnie ilość/notatka; produkt pojawia się na liście. |
| US-008 | Optimistic UI | Produkt pojawia się natychmiast; synchronizacja po odzyskaniu połączenia. |
| US-009 | Oznaczanie jako kupione | Checkbox (lub swipe); produkt w sekcji Kupione, wyszarzony. |
| US-010 | Obsługa duplikatów | Wykrywanie duplikatu nazwy; ConflictModal z edycją ilości; nadpisanie ilości (updateItem). |
| US-011 | Sortowanie | Drag & drop; zapis nowej kolejności (reorderItems). |

**Kryteria ukończenia widoku (impl-plan-04):**
- Widok ma nagłówek z miejscem na sync, listę aktywną, sekcję Kupione, StickyInput.
- Optimistic UI dla dodawania i toggle (opacity dla niesynchronizowanych).
- Share/Archive podpięte do modali lub placeholderów (część 8).

---

## 3. Architektura i zależności

- **Route:** TanStack Router, plik `lists.$listId.tsx` (ścieżka `/lists/:listId`).
- **Dane:** TanStack Query (`useQuery` / `useMutation`) z `networkMode: "offlineFirst"`; serwisy `listsService`, `listItemsService`.
- **UI:** React, Tailwind CSS, komponenty shadcn/ui (Button, Input, Dialog, Checkbox, DropdownMenu, Separator).
- **Typy:** `domain.types.ts` (ListItem, CreateListItemDTO, UpdateListItemDTO, SingleItemConflictState), `database.types.ts` (list_items Row).
- **Zależności między częściami:** ShareModal w części 8; SyncStatusIndicator w części 9; opcjonalnie swipe-to-delete i long-press w części 9.

---

## 4. Stan obecny (co już jest zaimplementowane)

- **ListItemsService:** getItemsByListId, createItem, updateItem, deleteItem, reorderItems, bulkCreateItems.
- **ListsService:** getListById, completeShoppingTrip, shareListWithEmail, updateList.
- **useListDetails:** pobieranie listy i pozycji, activeItems/completedItems, createItem/updateItem/deleteItem z optimistic updates, pendingIds, obsługa duplikatów (conflictState, resolveConflict, cancelConflict), archiveList.
- **ListDetailsHeader:** Wstecz, nazwa listy, placeholder na SyncStatusIndicator, menu (Udostępnij, Utwórz zestaw, Zmień nazwę, Zakończ zakupy).
- **ListItemRow:** checkbox, nazwa, ilość/notatka, GripVertical (drag handle), menu Usuń, isPending → opacity-70.
- **ActiveItemsList / CompletedItemsSection:** lista ListItemRow z onToggle, onDelete, pendingIds.
- **StickyInputBar:** pole tekstowe, Enter = Dodaj, walidacja (niepusty tekst), feedback przy błędzie (animate-pulse, komunikat).
- **ItemConflictDialog:** pole Ilość wypełnione existingItem.quantity, onConfirm(combinedQuantity), onCancel.
- **lists.$listId.tsx:** auth check, useListDetails, ListDetailsHeader (onShare → placeholder, onArchive → confirm dialog, onCreateSet/onRename puste), ActiveItemsList, CompletedItemsSection, StickyInputBar, ItemConflictDialog, dialog archiwizacji, dialog Udostępnij (placeholder).

---

## 5. Szczegółowy podział zadań

### 5.1. ListDetailsHeader
- Zachować: Wstecz, nazwa listy, Menu (Udostępnij, Utwórz zestaw, Zakończ zakupy/Archiwizuj).
- Miejsce na SyncStatusIndicator: już zarezerwowane (placeholder div); w części 9 podmiana na komponent.
- Opcjonalnie: pozycja „Zmień nazwę” w menu – już obecna (`onRename`); w widoku przekazywane `onRename={() => {}}`; do dopracowania: inline lub modal zmiany nazwy (np. wywołanie listsService.updateList + invalidacja).

### 5.2. SyncStatusIndicator (placeholder)
- Zarezerwowane w nagłówku; w części 9 pełna implementacja (zielony/pomarańczowy/czerwony).

### 5.3. ListItemRow
- Lewa: checkbox; środek: nazwa, ilość/notatka; prawa: drag handle (GripVertical), menu (Usuń). Tap zmienia checkbox.
- Long-press i swipe-to-delete: w części 9; obecnie wystarczy menu kontekstowe z „Usuń”.

### 5.4. StickyInputBar
- Przyklejony nad dolną nawigacją / do dołu ekranu (sticky bottom, pb-safe-area-bottom).
- Walidacja: niepusty tekst; Enter = Dodaj; feedback przy błędzie (pulsowanie, komunikat) – zaimplementowane.

### 5.5. Sekcja Kupione
- CompletedItemsSection: nagłówek „Kupione (N)”, Separator, wyszarzone ListItemRow (opacity-60, line-through). Toggle przenosi z powrotem do aktywnych – realizowane przez ten sam onToggle w useListDetails.

### 5.6. Optimistic UI
- useListDetails: createItemMutation, updateItemMutation, deleteItemMutation z onMutate (optimistic update), onError (rollback przy błędzie innym niż sieciowy), onSettled (usunięcie id z pendingIds).
- ListItemRow otrzymuje isPending; przy isPending stosowana opacity-70.

### 5.7. Integracja akcji nagłówka
- onShare → otwarcie ShareModal (część 8); do czasu wdrożenia – dialog placeholder „Udostępnianie listy – wkrótce”.
- onArchive → modal potwierdzenia + listsService.completeShoppingTrip + invalidacja zapytań + redirect na `/lists` – zaimplementowane.
- onCreateSet → nawigacja do flow „Utwórz zestaw z listy” lub modal; można zostawić pustą akcję do części zestawów.
- onRename → opcjonalnie modal/inline edycja nazwy + updateList + invalidacja.

---

## 6. Komponenty i zmiany w plikach

| Komponent / plik | Odpowiedzialność | Zmiany względem obecnego stanu |
|------------------|------------------|---------------------------------|
| `ListDetailsHeader.tsx` | Wstecz, nazwa, placeholder sync, menu | Ewentualnie dodać slot na przyszły SyncStatusIndicator (już jest placeholder). |
| `ListItemRow.tsx` | Checkbox, nazwa, ilość/notatka, handle, menu Usuń, isPending | Brak zmian wymaganych w ramach części 4; drag-and-drop w US-011 można dodać w tej samej części lub w 9. |
| `ActiveItemsList.tsx` | Lista aktywnych pozycji | Bez zmian. |
| `CompletedItemsSection.tsx` | Sekcja „Kupione” | Bez zmian. |
| `StickyInputBar.tsx` | Formularz dodawania produktu | Bez zmian. |
| `ItemConflictDialog.tsx` | Modal duplikatu – edycja ilości | Bez zmian. |
| `lists.$listId.tsx` | Strona widoku listy | Podłączenie onRename (opcjonalnie: modal zmiany nazwy). Upewnienie, że Share i Archive są podpięte (już są). |

---

## 7. Serwisy i API

- **listItemsService:** getItemsByListId(listId), createItem(CreateListItemDTO), updateItem(UpdateListItemDTO), deleteItem(itemId), reorderItems(items). Duplikaty: po stronie UI wykrywanie po nazwie (case-insensitive) w activeItems → wywołanie updateItem (merge quantity), nie createItem.
- **listsService:** getListById(listId), updateList(listId, { name }), completeShoppingTrip(listId), shareListWithEmail(listId, email). completeShoppingTrip wywołuje RPC archive_list_items (db-plan).

---

## 8. Stan i hook useListDetails

- **Zapytania:** list (getListById), list-items (getItemsByListId); networkMode: "offlineFirst".
- **Pochodne:** activeItems = items.filter(!is_bought), completedItems = items.filter(is_bought).
- **Mutations:** createItem, updateItem, deleteItem z optimistic update i pendingIds; rollback przy błędzie (z wyłączeniem błędów sieciowych).
- **Duplikaty:** conflictState (isOpen, conflictingItem, pendingName); handleAddItem sprawdza duplikat → ustawia conflictState; resolveConflict wywołuje updateItem(quantity) i zamyka modal.
- **Eksport:** list, activeItems, completedItems, pendingIds, isLoading, error, addItem, toggleItem, deleteItem, conflictState, resolveConflict, cancelConflict, isSubmitting, archiveList. Ewentualnie rozszerzenie o updateList (nazwa) i reorderItems gdy dodamy drag-and-drop.

---

## 9. Kryteria akceptacji i testy

- Wejście na `/lists/:listId` pokazuje nagłówek z nazwą listy, listę aktywnych, sekcję Kupione (jeśli są kupione), StickyInput.
- Dodanie produktu: wpisanie nazwy i Enter/Dodaj – produkt pojawia się od razu (optimistic); przy braku sieci element ma obniżoną opacity do czasu sync.
- Dodanie produktu o tej samej nazwie (aktywnego) otwiera ItemConflictDialog; zatwierdzenie z ilością aktualizuje istniejącą pozycję (updateItem).
- Zaznaczenie checkboxa przenosi pozycję do sekcji Kupione (wyszarzenie); odznaczenie przywraca do aktywnych.
- Usunięcie z menu kontekstowego usuwa pozycję z listy (optimistic).
- Menu nagłówka: Udostępnij → placeholder (docelowo ShareModal); Zakończ zakupy → potwierdzenie → archiwizacja i redirect na `/lists`.
- Walidacja StickyInput: puste pole + Enter wywołuje komunikat i pulsowanie.

---

## 10. Kolejność wdrożenia

1. Upewnienie się, że wszystkie komponenty (Header, ActiveItemsList, CompletedItemsSection, ListItemRow, StickyInputBar, ItemConflictDialog) są podłączone w `lists.$listId.tsx` i że useListDetails obsługuje optimistic UI oraz duplikaty.
2. Weryfikacja archiwizacji (completeShoppingTrip, modal, redirect) oraz placeholderów Share / Utwórz zestaw.
3. Opcjonalnie: implementacja „Zmień nazwę” (modal lub inline) z użyciem listsService.updateList i invalidacji zapytań.
4. Opcjonalnie w tej części lub w części 9: drag-and-drop (np. @dnd-kit) z wywołaniem reorderItems po upuszczeniu.

---

## 11. Uwagi i ryzyka

- **ShareModal / SyncStatusIndicator:** Świadomie pozostawione jako placeholdery do części 8 i 9; nie blokują uznania części 4 za ukończoną.
- **Drag-and-drop (US-011):** Serwis reorderItems jest gotowy; brak biblioteki DnD w projekcie – można dodać @dnd-kit/core lub podobną w ramach części 4 lub 9.
- **Offline:** networkMode: "offlineFirst" i rollback tylko przy błędach innych niż sieciowe zapewniają zgodność z US-008; pełna synchronizacja po powrocie sieci to zakres części 9.
- **Zmiana nazwy listy:** Wymaga sprawdzenia RLS dla update listów (już w db-plan); frontendowo wystarczy wywołanie updateList i invalidacja ["list", listId].



================================================
FILE: .ai/full-impl-plan-05-sets-dashboard-view-implementation-plan.md
================================================
# Pełny plan wdrożenia: Pulpit Zestawów (Sets Dashboard)

**Odniesienie:** ui-plan.md §2.4; impl-plan-05-sets-dashboard  
**Ścieżka:** `/sets`  
**Część:** 5 – Pulpit Zestawów

---

## 1. Cel i zakres

**Cel:** Wdrożenie widoku pulpitu zestawów (szablonów zakupowych) umożliwiającego przegląd dostępnych zestawów oraz dodawanie zestawu do wybranej listy z obsługą konfliktów nazw.

**Zakres:**
- Widok `/sets`: lista kart zestawów (nazwa, liczba produktów), przycisk „Dodaj do listy” na każdej karcie.
- Nagłówek z tytułem „Zestawy” i wyróżnieniem wizualnym (np. inny kolor) względem widoku list.
- Opcjonalnie: przycisk „Nowy zestaw” (tworzenie pustego zestawu – US-013).
- „Dodaj do listy” → wybór listy (dropdown lub modal z listą aktywnych list) → dodanie pozycji zestawu do wybranej listy.
- Obsługa konfliktów: gdy na liście docelowej istnieją już produkty o tej samej nazwie – SetConflictResolutionDialog (zaznaczenie, dla których zsumować ilości; konkatenacja tekstowa).
- Stan pusty: komunikat + ewentualnie „Utwórz pierwszy zestaw”.
- Bottom Nav: zakładka „Zestawy” aktywna na `/sets`.

---

## 2. Wymagania (User Stories i kryteria akceptacji)

| Id   | User Story | Kryterium |
|------|------------|-----------|
| US-013 | Zarządzanie zestawami | Zakładka Zestawy; tworzenie nowego pustego zestawu; edycja produktów w zestawie (szczegóły zestawu – osobny widok `/sets/:setId`). |
| US-014 | Dodawanie zestawu do listy | Przycisk „Dodaj do listy” przy zestawie; wybór listy; produkty z zestawu trafiają na listę; przy konfliktach nazw – ConflictResolutionModal (zwiększenie ilości / konkatenacja). |

**Kryteria ukończenia (impl-plan-05):**
- Pulpit zestawów wyświetla karty zestawów z przyciskiem „Dodaj do listy”.
- Wybór listy i dodanie zestawu do listy działa (z obsługą konfliktów przez SetConflictResolutionDialog).
- Wyróżnienie wizualne nagłówka względem widoku list.

---

## 3. Architektura i zależności

- **Route:** TanStack Router; plik `sets.index.tsx` (ścieżka `/sets/`); layout `sets.tsx` z `<Outlet />`.
- **Dane:** TanStack Query; serwisy `setsService`, `listsService`, `listItemsService`.
- **UI:** React, Tailwind CSS, komponenty shadcn/ui (Button, Card, Dialog, Dropdown/Select).
- **Typy:** `domain.types.ts` (ShoppingSet, SetItem, CreateSetDTO, CreateListItemDTO, SetConflictItem, SetResolutionResult); `database.types.ts` (sets, set_items).
- **Zależności:** SetConflictResolutionDialog (już istnieje w `list-details`); listItemsService.bulkCreateItems, listItemsService.updateItem dla konfliktów; listsService.getAllLists dla wyboru listy.

---

## 4. Stan obecny (co już jest zaimplementowane)

- **SetsService:** getAllSets(), getSetItems(setId), createSet(CreateSetDTO), createSetFromList(listId, CreateSetDTO), addSetItem, updateSetItem, deleteSetItem, deleteSet.
- **ListsService:** getAllLists() – zwraca listy użytkownika (przez list_members).
- **ListItemsService:** bulkCreateItems(items), updateItem(UpdateListItemDTO).
- **SetConflictResolutionDialog:** przyjmuje conflicts (SetConflictItem[]), nonConflictingItems (CreateListItemDTO[]), onResolve(SetResolutionResult), onCancel; checkboxy przy konfliktach (zsumować / nie); onResolve zwraca itemsToCreate i itemsToUpdate.
- **sets.index.tsx:** placeholder – auth check, tekst „Zestawy – wkrótce”.
- **sets.$setId.tsx:** placeholder – szczegóły zestawu (edycja) – osobny zakres; można zostawić placeholder lub zrealizować w części 6.
- **Header:** tytuł „Zestawy” dla `/sets` (ROUTE_TITLES).
- **BottomNav:** link do `/sets`, etykieta „Zestawy”.
- **MainLayout:** na ścieżkach `/sets` pokazywane są header i bottom nav (DASHBOARD_PATHS).

---

## 5. Szczegółowy podział zadań

### 5.1. Route i layout
- Trasa `/sets` i `/sets/` już istnieją (sets.tsx, sets.index.tsx).
- Zastąpić zawartość `sets.index.tsx` pełny
</kod_projektu>

<wymagania_projektu>
@.ai/prd.md
</wymagania_projektu>

<stos_technologiczny>
[tech-stack.md](mdc:.ai/tech-stack.md)
</stos_technologiczny>

Twoim zadaniem jest wygenerowanie szczegółowego planu testów, który będzie dostosowany do specyfiki projektu, uwzględniając wykorzystywane technologie, strukturę kodu oraz kluczowe elementy repozytorium. Plan testów powinien być napisany w języku polskim.

Przed stworzeniem planu testów, przeprowadź dogłębną analizę projektu wewnątrz bloku <analiza_projektu> w swoim bloku myślowym. W analizie uwzględnij:

1. Kluczowe komponenty projektu wynikające z analizy kodu:
   - Wymień i opisz główne komponenty projektu
2. Specyfikę stosu technologicznego i jego wpływ na strategię testowania:
   - Przeanalizuj każdy element stosu technologicznego i jego implikacje dla testowania
3. Priorytety testowe bazujące na strukturze repozytorium:
   - Zidentyfikuj i uszereguj obszary testowe według ważności
4. Potencjalne obszary ryzyka wymagające szczególnej uwagi w testach:
   - Wymień potencjalne ryzyka i uzasadnij, dlaczego wymagają specjalnej uwagi

Po zakończeniu analizy, stwórz plan testów wewnątrz bloku <plan_testów>. Plan powinien zawierać:

1. Wprowadzenie i cele testowania
2. Zakres testów
3. Typy testów do przeprowadzenia (np. testy jednostkowe, integracyjne, wydajnościowe)
4. Scenariusze testowe dla kluczowych funkcjonalności
5. Środowisko testowe
6. Narzędzia do testowania
7. Harmonogram testów
8. Kryteria akceptacji testów
9. Role i odpowiedzialności w procesie testowania
10. Procedury raportowania błędów

Pamiętaj, aby plan testów był:
- Dokładnie dostosowany do kontekstu projektu
- Uwzględniał specyfikę wykorzystywanych technologii
- Priorytetyzował kluczowe elementy repozytorium
- Był napisany w języku polskim
- Prezentował wysoką jakość i profesjonalizm

Rozpocznij od analizy, a następnie przejdź do tworzenia planu testów. Twój końcowy wynik powinien składać się tylko z planu testów i nie powinien powielać ani streszczać żadnej pracy wykonanej w bloku analizy projektu.

Przedstaw ten plan w formacie Markdown.